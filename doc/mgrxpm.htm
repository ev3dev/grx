<html>
<head>
   <meta charset="UTF-8">
   <meta name="Author" content="Mariano Alvarez Fern&aacute;ndez">
   <title>MGRX Programmer's Guide</title>
</head>
<body text="#000000" bgcolor="#CCCCCC" link="#0000EE" vlink="#551A8B" alink="#FF0000">

<center>
<h1><font color="#555555">M</font><font color="#FF0000">G</font><font color="#00CC00">R</font><font color="#0000FF">X</font>
<small>1.3.4</small></h1>
<h1>a C graphics library for DOS, Linux console &amp; X11 and Win32</h1>
<h2>Programmer's Manual</h2>
<p>Based on the original GRX manual written by: Csaba Biegl on August 10, 1992
<p>Adapted for MGRX by: Mariano Alvarez Fern&aacute;ndez on August 1, 2005
<p>Last update: July 7, 2020
</center>

<hr>
<h2>Abstract</h2>

<p>&nbsp;&nbsp;<b>MGRX</b> is a 2D graphics library derived from the GRX library.
GRX was originaly written by Csaba Biegl for DJ Delorie's DOS port of the GCC compiler.
<p>&nbsp;&nbsp;<b>MGRX</b> supports four platforms:
<ul>
<li>DOS (using the DJGPPv2 32bit compiler) with VGA and VESA compliant cards.
<li>Linux console (using the gcc compiler) on top of the framebuffer.
<li>Linux X11 (using the gcc compiler) running in a window.
<li>Win32 (tested with the TDM-GCC compiler, a Mingw32 distribution) running in a window.
</ul>
<p>&nbsp;&nbsp;For the Linux framebuffer and the Linux X11 versions three architectures
are supported: i386 (32bit), x86_64 (64bit) and ARM (32bit, tested in a Raspberry Pi 4
using Raspbian).
<p>&nbsp;&nbsp;Additionally <b>MGRX</b> can work without graphic output using the
memory driver.

<h2>Contents</h2>
<dir>
<li><a href="#why">MGRX versus GRX</a>
<li><a href="#hello">Hello world</a>
<li><a href="#dtfd">Data types, function declarations</a>
<li><a href="#sgd">Setting the graphics driver</a>
<li><a href="#svm">Setting video modes</a>
<li><a href="#gc">Graphics contexts</a>
<li><a href="#cu">How to use graphics contexts</a>
<li><a href="#dbuf">Example: double buffer</a>
<li><a href="#cm">Color management</a>
<li><a href="#pufc">Portable use of a few colors</a>
<li><a href="#gpri">Graphics primitives</a>
<li><a href="#ncgpri">Non-clipping graphics primitives</a>
<li><a href="#cld">Customized line drawing</a>
<li><a href="#pbpg">Patterns (bitmap, pixmaps and gradients)</a>
<li><a href="#pfgpri">Pattern filled graphics primitives</a>
<li><a href="#pld">Patterned line drawing</a>
<li><a href="#enc">About text encoding</a>
<li><a href="#td">Text drawing</a>
<li><a href="#utf8">Special UTF-8 text type considerations</a>
<li><a href="#ucs2">Recode to/from GR_UCS2_TEXT chartype</a>
<li><a href="#i18n">Internationalization</a>
<li><a href="#siuc">Drawing in user coordinates</a>
<li><a href="#gcur">Graphics cursors</a>
<li><a href="#pnm">Writing/reading PNM graphics files</a>
<li><a href="#png">Writing/reading PNG graphics files</a>
<li><a href="#jpeg">Writing/reading JPEG graphics files</a>
<li><a href="#misc">Miscellaneous functions</a>
<li><a href="#input">Input API</a>
<li><a href="#mouse">Mouse cursor handling</a>
<li><a href="#mdrv">The memory driver</a>
<li><a href="#ref">References</a>
</dir>

<hr>
<h2><a name="why">MGRX versus GRX</a></h2>

<p>&nbsp;&nbsp;<b>MGRX</b> (mgrx.fgrim.com) is a fork of GRX (grx.gnu.de).
The main MGRX differences are:</p>
<ul>
<li>Only provides the C API interface without add-ons (no Pascal, no Borland
BGI API)
<li>Has a new (and better I think) input API
<li>Includes (limited) internationalization support
<li>Supports (officially) only the 4 platforms mentioned above
</ul>

<p>&nbsp;&nbsp;The MGRX goal is to be a small, easy to use and maintain, C
graphics library.</p>

<hr>
<h2><a name="hello">Hello world</a></h2>

<p>&nbsp;&nbsp;The next program draws a double frame around the screen and
writes "Hello, MGRX world" centered, then it waits until a key is pressed.

<pre>
#include &lt;string.h>
#include &lt;mgrx.h>
#include &lt;mgrxkeys.h>

int main()
{
  char *message = "Hello, MGRX world";
  int x, y;
  GrTextOption grt;
  GrEvent ev;

  GrSetMode( GR_default_graphics );
  GrEventInit();

  grt.txo_font = GrGetDefaultFont();
  grt.txo_fgcolor = GrWhite();
  grt.txo_bgcolor = GrBlack();
  grt.txo_direct = GR_TEXT_RIGHT;
  grt.txo_xalign = GR_ALIGN_CENTER;
  grt.txo_yalign = GR_ALIGN_CENTER;
  grt.txo_chrtype = GR_BYTE_TEXT;

  GrBox( 0,0,GrMaxX(),GrMaxY(),GrWhite() );
  GrBox( 4,4,GrMaxX()-4,GrMaxY()-4,GrWhite() );

  x = GrMaxX()/2;
  y = GrMaxY()/2;
  GrDrawString( message,strlen( message ),x,y,&grt );

  GrEventWaitKeyOrClick(&ev);

  GrEventUnInit();
  return 0;
}
</pre>

<p>&nbsp;&nbsp;How to compile the hello world program (assuming the MGRX library was
previously installed)
<ul>
<li>DJGPP: gcc -o helomgrx.exe helomgrx.c -lmgrx
<li>TDM-GCC: gcc -o helomgrx.exe helomgrx.c -lmgrx -mwindows
<li>Linux X11 (i386): gcc -m32 -o helomgrx helomgrx.c -D__XWIN__ -lmgrxX -lX11
<li>Linux console (i386): gcc -m32 -o helomgrx helomgrx.c -lmgrx
<li>Linux X11 (x86_64): gcc -m64 -o helomgrx helomgrx.c -D__XWIN__ -lmgrxX -lX11
<li>Linux console (x86_64): gcc -m64 -o helomgrx helomgrx.c -lmgrx
<li>Linux X11 (ARM): gcc -o helomgrx helomgrx.c -D__XWIN__ -lmgrxX -lX11
<li>Linux console (ARM): gcc -o helomgrx helomgrx.c -lmgrx
</ul>
<hr>
<h2><a name="dtfd">Data types, function declarations</a></h2>

<p>&nbsp;&nbsp;All public data structures and graphics primitives meant
for usage by the application program are declared/prototyped in the header
files (in the 'include' sub-directory):

<ul>
<li><b>mgrx.h</b>  drawing-related structures and functions
<li><b>mgrxkeys.h</b>  platform independent key definitions
<li><b>mgrxcolr.h</b>  defines some colors tables in a portable way
<li><b>grdriver.h</b>  graphics driver format specifications
<li><b>grfontdv.h</b>  format of a font when loaded into memory
</ul>

<p>&nbsp;&nbsp;User programs normally only include <b>mgrx.h</b> and
<b>mgrxkeys.h</b> and optionally <b>mgrxcolr.h</b>

<hr>
<h2><a name="sgd">Setting the graphics driver</a></h2>

<p>&nbsp;&nbsp;The graphics driver is normally autodetected or set by the
final user using the environment variable <code>MGRXDRV</code>, but a program
can set it by function:
<pre>
int GrSetDriver(char *drvspec);
</pre>
<p>on succes it returns non-zero (TRUE). The drvspec string has
the same format as the environment variable:
<pre>
&lt;driver> gw &lt;width> gh &lt;height> nc &lt;colors>
</pre>
<p>available drivers are for:
<ul>
<li>DOS => stdega, stdvga, VESA, memory
<li>Linux console => linuxfb, memory
<li>Linux X11 => xwin, memory
<li>Win32 => win32, memory
</ul>

<p>the optionals gw, gh and nc parameters set the desired
default graphics mode. Normal values for 'nc' are 2, 16, 256, 64K and 16M.

<p>&nbsp;&nbsp;If neither the <code>MGRXDRV</code> variable exist, nor the
driver is set by program, MGRX will try to detect the correct driver when
first calling <code>GrSetMode</code> (see bellow)

<p>&nbsp;&nbsp;After initiated the current driver name can be obtained from:
<pre>
GrCurrentVideoDriver()->name
</pre>

<p>&nbsp;&nbsp;The type of the installed graphics adapter can be
determined with the function:
<pre>
GrVideoAdapter GrAdapterType(void);
</pre>
<p>it returns the type of the adapter as one of the following symbolic
constants (defined in <b>mgrx.h</b>):
<pre>
typedef enum _GR_videoAdapters {
  GR_UNKNOWN = (-1),     /* not known (before driver set) */
  GR_VGA,                /* VGA adapter */
  GR_EGA,                /* EGA adapter */
  GR_XWIN,               /* X11 driver */
  GR_WIN32,              /* W32 driver */
  GR_LNXFB,              /* Linux FB driver */
  GR_MEM                 /* memory only driver */
} GrVideoAdapter;
</pre>
<p>&nbsp;&nbsp;Note that the <code>VESA</code> driver return <code>GR_VGA
</code> here.

<hr>
<h2><a name="svm">Setting video modes</a></h2>

<p>&nbsp;&nbsp;Before a program can do any graphics drawing it has to
configure the graphics driver for the desired graphics mode. It is done with
the <code>GrSetMode</code> function as follows:
<pre>
int GrSetMode(int which,...); 
</pre>

<p>&nbsp;&nbsp;On succes it returns non-zero (TRUE). The <code>which</code>
parameter can be one of the following constants, declared in <b>mgrx.h</b>:
<pre>
  GR_default_graphics,
  GR_default_text,
  GR_width_height_graphics,
  GR_biggest_graphics,
  GR_width_height_color_graphics,
  GR_custom_graphics,
  GR_width_height_bpp_graphics,
  GR_custom_bpp_graphics,
  GR_NC_default_text,
  GR_NC_default_graphics,
  GR_NC_width_height_graphics,
  GR_NC_biggest_graphics,
  GR_NC_width_height_color_graphics,
  GR_NC_custom_graphics,
  GR_NC_width_height_bpp_graphics,
  GR_NC_custom_bpp_graphics,
</pre>

<p>&nbsp;&nbsp;The <code>GR_default_graphics</code> inits the graphic screen
with the resolution and color depth defined in the MGRXDRV environment
variable (or by te GrSetDriver function).

<p>&nbsp;&nbsp;The <code>GR_default_text</code> can be used, at the end of the
program, to return the graphics screen to his original state.

<p>&nbsp;&nbsp;The <code>GR_biggest_graphics</code> inits the graphic screen
with the maximum resolution and color depth supported by the graphic driver.
For Win32 and X11 this goes to full screen. If you want to limit the maximum
resolution to use, you can set the environment variable MGRXBIGG with
"maxw maxh".

<p>&nbsp;&nbsp;The <code> GR_width_height_graphics</code> mode requires the
two size arguments: <code>int width</code> and <code>int height</code>.

<p>&nbsp;&nbsp;The <code>GR_width_height_color_graphics</code>
mode requires three arguments: <code>int width</code>,
<code>int height</code> and <code>GrColor colors</code>.

<p>&nbsp;&nbsp;The <code>GR_width_height_bpp_graphics</code>
mode requires three arguments: <code>int width</code>, <code>int height</code>
and <code>int bpp</code> (bits per plane instead number of colors).

<p>&nbsp;&nbsp;The <code>GR_custom_graphics</code> and <code>
GR_custom_bpp_graphics</code> modes require five arguments:
<code>int width</code>, <code>int height</code>, <code>GrColor colors</code>
or <code>int bpp</code>, <code>int vx</code> and <code>int vy</code>. Using
this modes you can set a virtual screen of <code>vx</code> by <code>vy</code>
size, but it only works on some videomodes with the DOS drivers.

<p>&nbsp;&nbsp;The <code>GR_NC_...</code> modes are equivalent to the
<code>GR_..</code> ones, but they don't clear the video memory.

<p>&nbsp;&nbsp;Graphics drivers can provide info of the supported graphics modes, use the
next code skeleton to colect the data:
<pre>
{
  GrFrameMode fm;
  const GrVideoMode *mp;
  for(fm =GR_firstGraphicsFrameMode; fm <= GR_lastGraphicsFrameMode; fm++) {
    mp = GrFirstVideoMode(fm);
    while( mp != NULL ){
      ..
      .. use the mp info
      ..
      mp = GrNextVideoMode(mp))
    }
  }
}
</pre>
<p>&nbsp;&nbsp;Don't worry if you don't understand it, normal user programs
don't need to know about <code>FrameModes</code>. The <code>GrVideoMode
</code> structure has the following fields:
<pre>
typedef struct _GR_videoMode GrVideoMode;
struct _GR_videoMode {
  char    present;                    /* is it really available? */
  char    bpp;                        /* log2 of # of colors */
  short   width,height;               /* video mode geometry */
  short   mode;                       /* BIOS mode number (if any) */
  int     lineoffset;                 /* scan line length */
  int     privdata;                   /* driver can use it for anything */
  struct _GR_videoModeExt *extinfo;   /* extra info (maybe shared) */
};
</pre>
<p>the <code>width</code>, <code>height</code> and <code>bpp
</code> members are the useful information if you are interested in set
modes other than the <code>GR_default_graphics</code>.

<p>The current graphics mode (one of the valid <code>mode</code>
argument values for <code>GrSetMode</code>) can be obtained with:
<pre>
GrGraphicsMode GrCurrentMode(void);
</pre>
<p>while the current <code>GrVideoMode</code> can be determined with:
<pre>
GrVideoMode * GrCurrentVideoMode(void);
</pre>

<p>&nbsp;&nbsp;A user-defined function can be invoked every time the video
mode is changed (i.e. <code>GrSetMode</code> is called). This function should
not take any parameters and don't return any value. It can be installed (for
all subsequent <code>GrSetMode</code> calls) with the function:
<pre>
void GrSetModeHook(void (*hookfunc)(void));
</pre>

<hr>
<h2><a name="gc">Graphics contexts</a></h2>

<p>&nbsp;&nbsp;The library supports a set of drawing regions called contexts
(the <code>GrContext</code> structure). These can be in video memory or in
system memory. Contexts in system memory always have the same memory
organization as the video memory. When <code>GrSetMode</code> is called, a
default context is created which maps to the whole graphics screen. Contexts
are described by the <code>GrContext</code> data structure:
<pre>
typedef struct _GR_context GrContext;
struct _GR_context {
  struct _GR_frame    gc_frame;       /* frame buffer info */
  struct _GR_context *gc_root;        /* context which owns frame */
  int    gc_xmax;                     /* max X coord (width  - 1) */
  int    gc_ymax;                     /* max Y coord (height - 1) */
  int    gc_xoffset;                  /* X offset from root's base */
  int    gc_yoffset;                  /* Y offset from root's base */
  int    gc_xcliplo;                  /* low X clipping limit */
  int    gc_ycliplo;                  /* low Y clipping limit */
  int    gc_xcliphi;                  /* high X clipping limit */
  int    gc_ycliphi;                  /* high Y clipping limit */
  int    gc_usrxbase;                 /* user window min X coordinate */
  int    gc_usrybase;                 /* user window min Y coordinate */
  int    gc_usrwidth;                 /* user window width  */
  int    gc_usrheight;                /* user window height */
# define gc_baseaddr                  gc_frame.gf_baseaddr
# define gc_selector                  gc_frame.gf_selector
# define gc_onscreen                  gc_frame.gf_onscreen
# define gc_memflags                  gc_frame.gf_memflags
# define gc_lineoffset                gc_frame.gf_lineoffset
# define gc_driver                    gc_frame.gf_driver
};
</pre>
<p>&nbsp;&nbsp;The following four functions return information about the
layout of and memory occupied by a graphics context of size <code>width
</code> by <code>height</code> in the current graphics mode (as set up by
<code>GrSetMode</code>):
<pre>
int GrLineOffset(int width); 
int GrNumPlanes(void); 
long GrPlaneSize(int w,int h); 
long GrContextSize(int w,int h); 
</pre>
<p>&nbsp;&nbsp;<code>GrLineOffset</code> always returns the offset between
successive pixel rows of the context in bytes. <code>GrNumPlanes</code>
returns the number of bitmap planes in the current graphics mode. <code>
GrContextSize</code> calculates the total amount of memory needed by a
context, while <code>GrPlaneSize</code> calculates the size of a bitplane
in the context. The function:
<pre>
GrContext *GrCreateContext(int w,int h,char *memory[4],GrContext *where);
</pre>
<p>can be used to create a new context in system memory. The NULL pointer is
also accepted as the value of the <code>memory</code> and <code>where</code>
arguments, in this case the library allocates the necessary amount of memory
internally. It is a general convention in the library that functions
returning pointers to any <b>MGRX</b> specific data structure have a last
argument (most of the time named <code>where</code> in the prototypes) which
can be used to pass the address of the data structure which should be filled
with the result. If this <code>where</code> pointer has the value of NULL,
then the library allocates space for the data structure internally.

<p>&nbsp;&nbsp;The <code>memory</code> argument is really a 4 pointer array,
each pointer must point to space to handle <code>GrPlaneSize(w,h)</code>
bytes, really only <code>GrNumPlanes()</code> pointers must be malloced, the
rest can be NULL. Nevertheless the normal use (see below) is <code>gc =
GrCreateContext(w,h,NULL,NULL)</code>, so yo don't need to care about.

<p>&nbsp;&nbsp;The function:
<pre>
GrContext *GrCreateSubContext(int x1,int y1,int x2,int y2,
                              const GrContext *parent,GrContext *where);
</pre>
<p>creates a new sub-context which maps to a part of an existing context. The
coordinate arguments (<code>x1</code> through <code>y</code>2) are
interpreted relative to the parent context's limits. Pixel addressing is
zero-based even in sub-contexts, i.e. the address of the top left pixel is
(0,0) even in a sub-context which has been mapped onto the interior of its
parent context.

<p>&nbsp;&nbsp;Sub-contexts can be resized, but not their parents (i.e.
anything returned by <code>GrCreateContext</code> or set up by <code>
GrSetMode</code> cannot be resized -- because this could lead to
irrecoverable "loss" of drawing memory. The following function
can be used for this purpose:
<pre>
void GrResizeSubContext(GrContext *context,int x1,int y1,int x2,int y2); 
</pre>
<p>&nbsp;&nbsp;The current context structure is stored in a static location
in the library. (For efficiency reasons -- it is used quite frequently, and
this way no pointer dereferencing is necessary.) The context stores all
relevant information about the video organization, coordinate limits, etc...
The current context can be set with the:
<pre>
void GrSetContext(const GrContext *context);
</pre>
<p>function. This function will reset the current context to the full
graphics screen if it is passed the NULL pointer as argument. The value of
the current context can be saved into a <code>GrContext</code> structure
pointed to by <code>where</code> using:
<pre>
GrContext *GrSaveContext(GrContext *where); 
</pre>
<p>again, if <code>where</code> is NULL, the library allocates
the space, and you must remember to destory it, but remember this is a copy,
not the original context, so for typical use of this fuction (save the current
context, set a new context, do some drawings anf restore the original context)
is better to provide <code>where</code>. Example:
<pre>
void do_something()
{
  GrContext grc; 
  GrSaveContext(&grc);
  GrSetContext(another_context);
  ...do some drawing;
  GrSetContext(&grc);
}
</pre>

<p>The next two functions:
<pre>
const GrContext *GrCurrentContext(void);
const GrContext *GrScreenContext(void);
</pre>
<p>return the current context and the screen context respectively. Contexts
can be destroyed with:
<pre>
void GrDestroyContext(GrContext *context);
</pre>
<p>&nbsp;&nbsp;This function will free the memory occupied by the context
only if it was allocated originally by the library. The next three functions
set up and query the clipping limits associated with the current context:
<pre>
void GrSetClipBox(int x1,int y1,int x2,int y2); 
void GrGetClipBox(int *x1p,int *y1p,int *x2p,int *y2p); 
void GrResetClipBox(void);
</pre>
<p>&nbsp;&nbsp;<code>GrResetClipBox</code> sets the clipping limits to the
limits of context. These are the limits set up initially when a context is
created. There are three similar functions to sets/gets the clipping limits
of any context:
<pre>
void  GrSetClipBoxC(GrContext *c,int x1,int y1,int x2,int y2);
void  GrGetClipBoxC(const GrContext *c,int *x1p,int *y1p,int *x2p,int *y2p);
void  GrResetClipBoxC(GrContext *c);
</pre>
<p>&nbsp;&nbsp;The limits of the current context can be obtained using the
following functions:
<pre>
int GrMaxX(void); 
int GrMaxY(void); 
int GrSizeX(void); 
int GrSizeY(void);
</pre>
<p>&nbsp;&nbsp;The <code>Max</code> functions return the biggest valid
coordinate, while the <code>Size</code> functions return a value one higher.
The size of the graphics screen (regardless of the current context) can be
obtained with:
<pre>
int GrScreenX(void); 
int GrScreenY(void); 
</pre>
<p>&nbsp;&nbsp;If you had set a virtual screen (using a custom graphics mode),
the limits of the virtual screen can be fetched with:
<pre>
int GrVirtualX(void);
int GrVirtualY(void);
</pre>
<p>&nbsp;&nbsp;The routine:
<pre>
int GrScreenIsVirtual(void);
</pre>
<p>returns non zero if a virtual screen is set. The rectangle showed in the
real screen can be set with:
<pre>
int GrSetViewport(int xpos,int ypos);
</pre>
<p>and the current viewport position can be obtained by:
<pre>
int GrViewportX(void);
int GrViewportY(void);
</pre>

<hr>
<h2><a name="cu">How to use graphics contexts</a></h2>

<p>&nbsp;&nbsp;Here is an example of standard graphic context use:
<pre>
GrContext *grc;

if( (grc = GrCreateContext( w,h,NULL,NULL )) == NULL ){
  ...process the error
  }
else{
  GrSetContext( grc ); /* now all drawing will be in grc! */
  ...do some drawing
  ...and probably bitblt to the screen context
  GrSetContext( NULL ); /* return to the screen context! */
  GrDestroyContext( grc );
  }
</pre>
<p>&nbsp;&nbsp;But if you have a GrContext variable (not a pointer) that you
want to use (probably because is static to some routines) you can do:
<pre>
static GrContext grc; /* not a pointer!! */

if( GrCreateContext( w,h,NULL,&grc )) == NULL ){
  ...process the error
  }
else{
  GrSetContext( &grc ); /* now all drawing will be in grc! */
  ...do some drawing
  ...and probably bitblt to the screen context
  GrSetContext( NULL ); /* return to the screen context! */
  GrDestroyContext( &grc );
  }
</pre>
<p>&nbsp;&nbsp;Note that <code>GrDestoryContext</code> knows if grc was
automatically malloced or not!!

<p>&nbsp;&nbsp;Only if you don't want <code>GrCreateContext</code> use malloc
at all, you must allocate the memory buffers and pass it to <code>
GrCreateContext</code>.

<p>&nbsp;&nbsp;Using <code>GrCreateSubContext</code> is the same, except it
doesn't need the buffer, because it uses the parent buffer.

<hr>
<h2><a name="dbuf">Example: double buffer</a></h2>

<p>&nbsp;&nbsp;Using contexts it is easy to implement double buffering, a
technique to first draw each frame in memory and display them on screen at
once, this makes changes to the screen appear much smoother:
<pre>
GrContext *grc;

if( (grc = GrCreateContext( GrScreenX(),GrScreenY(),NULL,NULL )) == NULL ){
  ...process the error and exit
  }

GrSetContext( grc ); /* now all drawing will be in grc! */
while(1){
  ...draw the frame
  GrBitBlt(GrScreenContext(),0,0,grc,0,0,grc->gc_xmax,grc->gc_ymax,GrWRITE);
  ...and probably process user input
}
</pre>

<hr>
<h2><a name="cm">Color management</a></h2>

<p>&nbsp;&nbsp;<b>MGRX</b> defines the type <code>GrColor</code> for color
variables. <code>GrColor</code> it's a 32 bits integer. The 8 left bits are
reserved for the write mode (see below). The 24 bits right are the color
value.

<p>&nbsp;&nbsp;The library supports two models for color management. In the
'indirect' (or color table) model, color values are indices to a color table.
The color table slots will be allocated with the highest resolution supported
by the hardware (EGA: 2 bits, VGA: 6 bits) with respect to the component
color intensities. In the 'direct' (or RGB) model, color values map directly
into component color intensities with non-overlapping bitfields of the color
index representing the component colors.

<p>&nbsp;&nbsp;Color table model is supported until 256 color modes. The RGB
model is supported in 256 color and up color modes.

<p>&nbsp;&nbsp;In RGB model the color index map to component color
intensities depend on the video mode set, so it can't be assumed the
component color bitfields (but if you are curious check the <code>GrColorInfo
</code> global structure in <b>mgrx.h</b>).

<p>&nbsp;&nbsp;After the first <code>GrSetMode</code> call two colors are
always defined: black and white. The color values of these two colors are
returned by the functions:
<pre>
GrColor GrBlack(void); 
GrColor GrWhite(void);
</pre>
<p>&nbsp;&nbsp;<code>GrBlack()</code> is guaranteed to be 0.

<p>&nbsp;&nbsp;The library supports five write modes (a write mode descibes
the operation between the actual bit color and the one to be set): write,
XOR, logical OR, logical AND and IMAGE. These can be selected with OR-ing
the color value with one of the following constants declared in <b>mgrx.h
</b>:
<pre>
#define GrWRITE       0UL            /* write color */
#define GrXOR         0x01000000UL   /* to "XOR" any color to the screen */
#define GrOR          0x02000000UL   /* to "OR" to the screen */
#define GrAND         0x03000000UL   /* to "AND" to the screen */
#define GrIMAGE       0x04000000UL   /* BLIT: write, except given color */
</pre>
<p>&nbsp;&nbsp;The <code>GrIMAGE</code> write mode only works with the
<code>bitblt</code> function.

<p>&nbsp;&nbsp;By convention, the no-op color is obtained by combining color
value 0 (black) with the XOR operation. This no-op color has been defined in
<b>mgrx.h</b> as:
<pre>
#define GrNOCOLOR     (GrXOR | 0)    /* GrNOCOLOR is used for "no" color */
</pre>
<p>&nbsp;&nbsp;The write mode part and the color value part of a <code>
GrColor</code> variable can be obtained OR-ing it with one of the following
constants declared in <b>mgrx.h</b>:
<pre>
#define GrCVALUEMASK  0x00ffffffUL   /* color value mask */
#define GrCMODEMASK   0xff000000UL   /* color operation mask */
</pre>
<p>&nbsp;&nbsp;The number of colors in the current graphics mode is returned
by the:
<pre>
GrColor GrNumColors(void);
</pre>
<p>function, while the number of unused, available color can be obtained by
calling:
<pre>
GrColor GrNumFreeColors(void); 
</pre>
<p>&nbsp;&nbsp;Colors can be allocated with the:
<pre>
GrColor GrAllocColor(int r,int g,int b);
GrColor GrAllocColor2(long hcolor);
</pre>
<p>functions (component intensities can range from 0 to 255, <code>
hcolor</code> must be in 0xRRGGBB format), or with the:
<pre>
GrColor GrAllocCell(void);
</pre>
<p>function. In the second case the component intensities of the returned
color can be set with:
<pre>
void GrSetColor(GrColor color,int r,int g,int b); 
</pre>
<p>&nbsp;&nbsp;In the color table model all <code>Alloc</code> functions
return <code>GrNOCOLOR</code> if there are no more free colors available. In
the RGB model <code>GrNumFreeColors</code> returns 0 and <code>GrAllocCell
</code> always returns <code>GrNOCOLOR</code>, as colors returned
by <code>GrAllocCell</code> are meant to be changed -- what is not supposed
to be done in RGB mode. Also note that <code>GrAllocColor</code> operates
much more efficiently in RGB mode, and that it never returns <code>GrNOCOLOR
</code> in this case.

<p>&nbsp;&nbsp;Color table entries can be freed (when not in RGB mode) by
calling:
<pre>
void GrFreeColor(GrColor color);
</pre>
<p>&nbsp;&nbsp;The component intensities of any color can be queried using
one of this functions:
<pre>
void GrQueryColor(GrColor c,int *r,int *g,int *b); 
void GrQueryColor2(GrColor c,long *hcolor); 
</pre>
<p>&nbsp;&nbsp;Initially the color system is in color table (indirect) model
if there are 256 or less colors. 256 color modes can be put into the RGB
model by calling:
<pre>
void GrSetRGBcolorMode(void);
</pre>
<p>&nbsp;&nbsp;The color system can be reset (i.e. put back into color table
model if possible, all colors freed except for black and white) by calling:
<pre>
void GrResetColors(void);
</pre>
<p>&nbsp;&nbsp;The function:
<pre>
void GrRefreshColors(void);
</pre>
<p>reloads the currently allocated color values into the video hardware. This
function is not needed in typical applications, unless the display adapter
is programmed directly by the application.

<p>&nbsp;&nbsp;This functions:
<pre>
GrColor GrAllocColorID(int r,int g,int b);
GrColor GrAllocColor2ID(long hcolor);
void GrQueryColorID(GrColor c,int *r,int *g,int *b);
void GrQueryColor2ID(GrColor c,long *hcolor);
</pre>
<p>are inlined versions (except if you compile <b>MGRX</b> with <b>
GRX_SKIP_INLINES</b> defined) to be used in the RGB model (in the color
table model they call the normal routines).

<hr>
<h2><a name="pufc">Portable use of a few colors</a></h2>

<p>&nbsp;&nbsp;People that only want to use a few colors find the <b>MGRX</b>
color handling a bit confusing, but it gives the power to manage a lot of
color deeps and two color models. Here are some guidelines for using a few
colors in a portable way in <b>MGRX</b> programs.

<h3>Using the include file "mgrxcolr.h" (new in version 1.1.2)</h3>

<p>&nbsp;&nbsp;The "mgrxcolr.h" provides defines and functions to use two
color tables, a EGA one with 16 colors that you can use with 4bpp and more
graphics modes, and another table with the 138 WEB colors, as defined by 
the w3.org, that you can use with 8bpp and more graphics modes.

<p>&nbsp;&nbsp;For each table you have:

<ul>
<li>A set of defines with the RGB color definitions, by example:
<pre>
#define EGAR_BLACK          0x000000
#define EGAR_BLUE           0x0000AA
#define EGAR_GREEN          0x00AA00
...
#define WEBR_ALICEBLUE              0xF0F8FF 
#define WEBR_ANTIQUEWHITE           0xFAEBD7 
#define WEBR_AQUAMARINE             0x7FFFD4 
...
</pre>
<p>You can use directly those defines to allocate colors with
<code>GrAllocColor2(XXXR_xxx)</code>

<li>A extern reference for each table and a function you need to call just
once to allocate colors:
<pre>
extern GrColorTableDef GrEgaColorTable[];
int GrGenEgaColorTable(void);
extern GrColorTableDef GrWebColorTable[];
int GrGenWebColorTable(void);
</pre>
<p>As an extra in the tables are the color names.
<li>Another set of defines you can use, after calling the GrGen.. function,
to reference the allocated colors, by example:
<pre>
#define EGAC_BLACK          GrEgaColorTable[0].color
#define EGAC_BLUE           GrEgaColorTable[1].color
#define EGAC_GREEN          GrEgaColorTable[2].color
...
#define WEBC_ALICEBLUE              GrWebColorTable[0].color 
#define WEBC_ANTIQUEWHITE           GrWebColorTable[1].color 
#define WEBC_AQUAMARINE             GrWebColorTable[2].color 
...
</pre>
<p>Note that you can't use those defines to initialize static variables
because the corresponding table is not populated yet.

<li>A last set of defines with the index of each color in the corresponding
table, by example:
<pre>
#define EGAI_BLACK          0
#define EGAI_BLUE           1
#define EGAI_GREEN          2
...
#define WEBI_ALICEBLUE              0 
#define WEBI_ANTIQUEWHITE           1 
#define WEBI_AQUAMARINE             2 
...
</pre>
<p>You can use those defines to initialize static variables, but to use the
colors you need to write <code>GrXXXColorTable[XXXI_xxx].color</code> or the
macro <code>XXXColor(XXXI_xxx)</code>
</ul>

<p>&nbsp;&nbsp;There is an example of how to use each case in the "clrtable"
test program.

<h3>Using the  GrAllocEgaColors function</h3>

<p>&nbsp;&nbsp;This is the classic method to use the 16 EGA colors in a
portable way that also works in versions prior to 1.1.2. We need this
<b>MGRX</b> function:
<pre>
GrColor *GrAllocEgaColors(void);
</pre>
<p>it returns a 16 <code>GrColor</code> array with the 16 ega colors alloced
(really it's a trivial function, read the source <b>src/setup/colorega.c</b>).
We can use a construction like that:

<p>&nbsp;&nbsp;First, in your C code make a global pointer, and init it after
set the graphics mode:
<pre>
GrColor *egacolors;
....
int your_setup_function( ... )
{
  ...
  GrSetMode( ... )
  ...
  egacolors = GrAllocEgaColors();
  ...
}
</pre>
<p>&nbsp;&nbsp;Next, add this to your main include file:
<pre>
extern GrColor *egacolors;
#define BLACK        egacolors[0]
#define BLUE         egacolors[1]
#define GREEN        egacolors[2]
#define CYAN         egacolors[3]
#define RED          egacolors[4]
#define MAGENTA      egacolors[5]
#define BROWN        egacolors[6]
#define LIGHTGRAY    egacolors[7]
#define DARKGRAY     egacolors[8]
#define LIGHTBLUE    egacolors[9]
#define LIGHTGREEN   egacolors[10]
#define LIGHTCYAN    egacolors[11]
#define LIGHTRED     egacolors[12]
#define LIGHTMAGENTA egacolors[13]
#define YELLOW       egacolors[14]
#define WHITE        egacolors[15]
</pre>
<p>&nbsp;&nbsp;Now you can use the defined colors in your code (by example:
<code>GrClearScreen(YELLOW);</code>). Note that if
you are in color table model in a 16 color mode, you have exhausted the color
table. Note too that this don't work to initialize static variables with a
color, because egacolors is not initialized.

<hr>
<h2><a name="gpri">Graphics primitives</a></h2>

<p>&nbsp;&nbsp;The screen, the current context or the current clip box can be
cleared (i.e. set to a desired background color) by using one of the following
three functions:
<pre>
void GrClearScreen(GrColor bg); 
void GrClearContext(GrColor bg); 
void GrClearClipBox(GrColor bg);
</pre>
<p>Any context can be cleared using this function:
<pre>
void GrClearContextC(GrContext *ctx, GrColor bg);
</pre>
<p>&nbsp;&nbsp;Thanks to the special <code>GrColor</code> definition, you can
do more than simple clear with this functions, by example with:
<pre>
GrClearScreen( GrWhite()|GrXOR );
</pre>
<p>the graphics screen is negativized, do it again and the screen is restored.

<p>&nbsp;&nbsp;The following line drawing graphics primitives are supported
by the library:
<pre>
void GrPlot(int x,int y,GrColor c);
void GrLine(int x1,int y1,int x2,int y2,GrColor c); 
void GrHLine(int x1,int x2,int y,GrColor c); 
void GrVLine(int x,int y1,int y2,GrColor c); 
void GrBox(int x1,int y1,int x2,int y2,GrColor c); 
void GrCircle(int xc,int yc,int r,GrColor c); 
void GrEllipse(int xc,int yc,int xa,int ya,GrColor c); 
void GrCircleArc(int xc,int yc,int r,int start,int end,int style,GrColor c); 
void GrEllipseArc(int xc,int yc,int xa,int ya,
                  int start,int end,int style,GrColor c);
void GrPolyLine(int numpts,int points[][2],GrColor c); 
void GrPolygon(int numpts,int points[][2],GrColor c); 
</pre>
<p>&nbsp;&nbsp;All primitives operate on the current graphics context. The
last argument of these functions is always the color to use for the drawing.
The <code>HLine</code> and <code>VLine</code> primitives are for drawing
horizontal and vertical lines. They have been included in the library because
they are more efficient than the general line drawing provided by <code>
GrLine</code>. The ellipse primitives can only draw ellipses with their major
axis parallel with either the X or Y coordinate axis. They take the half X
and Y axis length in the <code>xa</code> and <code>ya</code> arguments. The
arc (circle and ellipse) drawing functions take the start and end angles in
tenths of degrees (i.e. meaningful range: 0 ... 3600). The angles are
interpreted counter-clockwise starting from the positive X axis. The style
argument can be one of this defines from <b>mgrx.h</b>:
<pre>
#define GR_ARC_STYLE_OPEN       0
#define GR_ARC_STYLE_CLOSE1     1
#define GR_ARC_STYLE_CLOSE2     2
</pre>
<p>&nbsp;&nbsp;<code>GR_ARC_STYLE_OPEN</code> draws only the arc,
<code>GR_ARC_STYLE_CLOSE1</code> closes the arc with a line between his start
and end point, <code>GR_ARC_STYLE_CLOSE2</code> draws the typical cake slice.
This routine:
<pre>
void GrLastArcCoords(int *xs,int *ys,int *xe,int *ye,int *xc,int *yc);
</pre>
<p>can be used to retrieve the start, end, and center points used by the
last arc drawing functions.

<p>&nbsp;&nbsp;The polyline and polygon primitives take the address of an
n by 2 coordinate array. The X values should be stored in the elements with
0 second index, and the Y values in the elements with a second index value
of 1. Coordinate arrays passed to the polygon primitive can either contain
or omit the closing edge of the polygon -- the primitive will append it to
the list if it is missing.

<p>&nbsp;&nbsp;Because calculating the arc points it's a very time consuming
operation, there are two functions to pre-calculate the points, that can be
used next with polyline and polygon primitives:
<pre>
int  GrGenerateEllipse(int xc,int yc,int xa,int ya,
                       int points[GR_MAX_ELLIPSE_POINTS][2]);
int  GrGenerateEllipseArc(int xc,int yc,int xa,int ya,int start,int end,
                          int points[GR_MAX_ELLIPSE_POINTS][2]);
</pre>
<p>&nbsp;&nbsp;The following filled primitives are available:
<pre>
void GrFilledBox(int x1,int y1,int x2,int y2,GrColor c); 
void GrFramedBox(int x1,int y1,int x2,int y2,int wdt,const GrFBoxColors *c);
void GrFilledCircle(int xc,int yc,int r,GrColor c); 
void GrFilledEllipse(int xc,int yc,int xa,int ya,GrColor c); 
void GrFilledCircleArc(int xc,int yc,int r,
                       int start,int end,int style,GrColor c);
void GrFilledEllipseArc(int xc,int yc,int xa,int ya,
                        int start,int end,int style,GrColor c);
void GrFilledPolygon(int numpts,int points[][2],GrColor c); 
void GrFilledConvexPolygon(int numpts,int points[][2],GrColor c); 
</pre>
<p>&nbsp;&nbsp;Similarly to the line drawing, all of the above primitives
operate on the current graphics context. The <code>GrFramedBox</code>
primitive can be used to draw motif-like shaded boxes and "ordinary" framed
boxes as well. The <code>x1</code> through <code>y2</code> coordinates
specify the interior of the box, the border is outside this area,
<code>wdt</code> pixels wide. The primitive uses five different
colors for the interior and four borders of the box which are specified
in the <code>GrFBoxColors</code> structure:
<pre>
typedef struct { 
  GrColor fbx_intcolor; 
  GrColor fbx_topcolor; 
  GrColor fbx_rightcolor; 
  GrColor fbx_bottomcolor; 
  GrColor fbx_leftcolor; 
} GrFBoxColors;
</pre>
<p>&nbsp;&nbsp;The <code>GrFilledConvexPolygon</code> primitive can be used
to fill convex polygons. It can also be used to fill some concave polygons
whose boundaries do not intersect any horizontal scan line more than twice.
All other concave polygons have to be filled with the (somewhat less
efficient) <code>GrFilledPolygon</code> primitive. This primitive can also
be used to fill several disjoint nonoverlapping polygons in a single
operation.

<p>&nbsp;&nbsp;The function:
<pre>
void GrFloodFill(int x, int y, GrColor border, GrColor c);
</pre>
<p>flood-fills the area bounded by the color <code>border</code> using
<code>x</code>, <code>y</code> like the starting point.

<p>&nbsp;&nbsp;Floodspill is a color replacer, replacing color A with color B.
This is quite useful for highlighting a selected item in a list,  or changing
a selected color(s) in a multi colored area.
<pre>
void GrFloodSpill(int x1, int y1, int x2, int y2,
                 GrColor old_c, GrColor new_c)
</pre>
<p>replaces old color with new color in the rectangle bounded by x1, y1, x2, y2.
<pre>
void GrFloodSpillC(GrContext *ctx, int x1, int y1, int x2, int y2,
                  GrColor old_c, GrColor new_c)
</pre>
<p>as above but in the specified context.
<pre>
void GrFloodSpill2(int x1, int y1, int x2, int y2,
                  GrColor old_c1, GrColor new_c1,
                  GrColor old_c2, GrColor new_c2)
</pre>
<p>replaces 2 colors, a one stop shop for highlighting a selection in a list.
<pre>
void GrFloodSpillC2(GrContext *ctx, int x1, int y1, int x2, int y2,
                  GrColor old_c1, GrColor new_c1,
                  GrColor old_c2, GrColor new_c2)
</pre>
<p>as above but in the specified context.

<p>&nbsp;&nbsp;The current color value of any pixel in the current context
can be obtained with:
<pre>
GrColor GrPixel(int x,int y);
</pre>
<p>and:
<pre>
GrColor GrPixelC(GrContext *c,int x,int y);
</pre>
<p>do the same for any context.

<p>&nbsp;&nbsp;Rectangular areas can be transferred within a context or
between contexts by calling:
<pre>
void GrBitBlt(GrContext *dest,int x,int y,GrContext *source,
              int x1,int y1,int x2,int y2,GrColor op);
</pre>
<p><code>x</code>, <code>y</code> is the position in the destination context,
and <code>x1</code>, <code>y1</code>, <code>x2</code>, <code>y2</code>
the area from the source context to be transfered. The <code>op</code>
argument should be one of supported color write modes (GrWRITE, GrXOR, GrOR,
GrAND, GrIMAGE), it will control how the pixels from the source context are
combined with the pixels in the destination context (the GrIMAGE op must be
ored with the color value to be handled as transparent). If either the source
or the destination context argument is the NULL pointer then the current
context is used for that argument.

<p>&nbsp;&nbsp;GrBitblt works pixel by pixel, there is another function that
can stretch the source to the destination:

<pre>
void GrStretchBlt(GrContext *dst,int dx1,int dy1,int dx2,int dy2,
                  GrContext *src,int x1,int y1,int x2,int y2,GrColor oper);
</pre>
<p>here <code>dx1</code>, <code>dy1</code>, <code>dx2</code>, <code>dy2</code>
define the destination area to stretch the source area.

<p>&nbsp;&nbsp;A efficient form to get/put pixels from/to a context can be
achieved using the next functions:
<pre>
const GrColor *GrGetScanline(int x1,int x2,int yy);
const GrColor *GrGetScanlineC(GrContext *ctx,int x1,int x2,int yy);
void GrPutScanline(int x1,int x2,int yy,const GrColor *c, GrColor op);
</pre>
<p>&nbsp;&nbsp;The <code>Get</code> functions return a pointer to a static
<code>GrColor</code> pixel array (or NULL if they fail) with the color values
of a row (<code>yy</code>) segment (<code>x1</code> to <code>x2</code>).
<code>GrGetScanline</code> uses the current context. <code>GrGestScanlineC
</code> uses the context <code>ctx</code> (that can be NULL to refer to the
current context). Note that the output is only valid until the next
<b>MGRX</b> call.

<p>&nbsp;&nbsp;<code>GrPutScanline</code> puts the GrColor pixel array
<code>c</code> on the <code>yy</code> row segmet defined by <code>x1</code>
to <code>x2</code> in the current context using the <code>op</code>
operation. <code>op</code> can be any of <code>GrWRITE</code>,
<code>GrXOR</code>, <code>GrOR</code>, <code>GrAND</code> or
<code>GrIMAGE</code>. Data in <code>c</code> must fit <code>GrCVALUEMASK
</code> otherwise the results are implementation dependend. So you can't
supply operation code with the pixel data!.

<hr>
<h2><a name="ncgpri">Non-clipping graphics primitives</a></h2>

<p>&nbsp;&nbsp;There is a non-clipping version of some of the elementary
primitives. These are somewhat more efficient than the regular versions.
These are to be used only in situations when it is absolutely certain that
no drawing will be performed beyond the boundaries of the current context.
Otherwise the program will almost certainly crash! The reason for including
these functions is that they are somewhat more efficient than the regular,
clipping versions. ALSO NOTE: These function do not check for conflicts with
the mouse cursor. (See the explanation about the mouse cursor handling later
in this document.) The list of the supported non-clipping primitives:
<pre>
void GrPlotNC(int x,int y,GrColor c); 
void GrLineNC(int x1,int y1,int x2,int y2,GrColor c); 
void GrHLineNC(int x1,int x2,int y,GrColor c); 
void GrVLineNC(int x,int y1,int y2,GrColor c); 
void GrBoxNC(int x1,int y1,int x2,int y2,GrColor c); 
void GrFilledBoxNC(int x1,int y1,int x2,int y2,GrColor c); 
void GrFramedBoxNC(int x1,int y1,int x2,int y2,int wdt,const GrFBoxColors *c);
void GrBitBltNC(GrContext *dst,int x,int y,GrContext *src,
                int x1,int y1,int x2,int y2,GrColor op);
GrColor GrPixelNC(int x,int y);
GrColor GrPixelCNC(GrContext *c,int x,int y);
</pre>

<hr>
<h2><a name="cld">Customized line drawing</a></h2>

<p>&nbsp;&nbsp;The basic line drawing graphics primitives described
previously always draw continuous lines which are one pixel wide. There is
another group of line drawing functions which can be used to draw wide
and/or patterned lines. These functions have similar parameter passing
conventions as the basic ones with one difference: instead of the color
value a pointer to a structure of type <code>GrLineOption</code> has to be
passed to them. The definition of the <code>GrLineOption</code> structure:
<pre>
typedef struct {
  GrColor lno_color;             /* color used to draw line */
  int     lno_width;             /* width of the line */
  int     lno_pattlen;           /* length of the dash pattern */
  unsigned char *lno_dashpat;    /* draw/nodraw pattern */
} GrLineOption;
</pre>
<p>&nbsp;&nbsp;The <code>lno_pattlen</code> structure element should be equal
to the number of alternating draw -- no draw section length values in the
array pointed to by the <code>lno_dashpat</code> element. The dash pattern
array is assumed to begin with a drawn section. If the pattern length is
equal to zero a continuous line is drawn.

<p>&nbsp;&nbsp;Example, a white line 3 bits wide (thick) and pattern 6 bits
draw, 4 bits nodraw:
<pre>
GrLineOption mylineop;
...
mylineop.lno_color = GrWhite();
mylineop.lno_width = 3;
mylineop.lno_pattlen = 2;
mylineop.lno_dashpat = "\x06\x04";
</pre>
<p>&nbsp;&nbsp;The available custom line drawing primitives:
<pre>
void GrCustomLine(int x1,int y1,int x2,int y2,const GrLineOption *o);
void GrCustomBox(int x1,int y1,int x2,int y2,const GrLineOption *o);
void GrCustomCircle(int xc,int yc,int r,const GrLineOption *o);
void GrCustomEllipse(int xc,int yc,int xa,int ya,const GrLineOption *o);
void GrCustomCircleArc(int xc,int yc,int r,
                       int start,int end,int style,const GrLineOption *o);
void GrCustomEllipseArc(int xc,int yc,int xa,int ya,
                        int start,int end,int style,const GrLineOption *o);
void GrCustomPolyLine(int numpts,int points[][2],const GrLineOption *o);
void GrCustomPolygon(int numpts,int points[][2],const GrLineOption *o);
</pre>

<hr>
<h2><a name="pbpg">Patterns (bitmaps, pixmaps and gradients)</a></h2>

<p>&nbsp;&nbsp;The library also supports pattern filled and paterned versions
of the filled and custom primitives described above. These functions have similar
parameter passing conventions as the basic ones with one difference: instead
of the color value a pointer to an union of type 'GrPattern' has to be passed
to them. The <code>GrPattern</code> union can contain a bitmap a pixmap or a
gradient fill pattern. The first integer slot in the union determines which
type it is. Bitmap fill patterns are rectangular arrays of bits, each set
bit representing the foreground color of the fill operation, and each zero
bit representing the background. Both the foreground and background colors
can be combined with any of the supported logical operations. Bitmap fill
patterns have one restriction: their width must be eight pixels. Pixmap
fill patterns are very similar to contexts. Gradients are smooth color
changes, can be linear or radial. Gradients can be used only in rgb
color modes. The relevant structure
declarations (from <b>mgrx.h</b>):
<pre>
#define GR_PTYPE_BITMAP   0
#define GR_PTYPE_PIXMAP   1
#define GR_PTYPE_GRADIENT 2

/*
 * BITMAP: a mode independent way to specify a fill pattern of two
 *   colors. It is always 8 pixels wide (1 byte per scan line), its
 *   height is user-defined. SET THE TYPE FLAG TO GR_PTYPE_BITMAP!!!
 */
typedef struct _GR_bitmap {
    int     bmp_ptype;              /* type flag for pattern union */
    int     bmp_height;             /* bitmap height */
    char   *bmp_data;               /* pointer to the bit pattern */
    GrColor bmp_fgcolor;            /* foreground color for fill */
    GrColor bmp_bgcolor;            /* background color for fill */
    int     bmp_memflags;           /* set if dynamically allocated */
} GrBitmap;

/*
 * PIXMAP: a fill pattern stored in a layout identical to the video RAM
 *   for filling using 'bitblt'-s. It is mode dependent, typically one
 *   of the library functions is used to build it. SET THE TYPE FLAG TO
 *   GR_PTYPE_PIXMAP!!!
 */
typedef struct _GR_pixmap {
    int     pxp_ptype;              /* type flag for pattern union */
    int     pxp_width;              /* pixmap width (in pixels)  */
    int     pxp_height;             /* pixmap height (in pixels) */
    GrColor pxp_oper;               /* bitblt mode (SET, OR, XOR, AND, IMAGE) */
    struct _GR_frame pxp_source;    /* source context for fill */
} GrPixmap;

/*
 * GRADIENT: a fill pattern that change color in the direction defined by a
 *   vector (linar gradient) or from the distance to a point (radial gradient).
 *   Only can be used in rgb mode. SET THE TYPE FLAG TO GR_PTYPE_GRADIENT!!!
 */
typedef struct {
    int xi, yi, xf, yf;             // vector that define the gradient
    float dist_if;                  // distance from i to f (calculated)
} GrGrdLinearData;

typedef struct {
    int xc, yc, r;                  // center and radius that define the gradient
} GrGrdRadialData;

typedef struct {
    int dist;                       // normalized distance (0 to 255)
    GrColor c;                      // color
} GrGrdStop;

#define GR_LINEAR_GRADIENT 0
#define GR_RADIAL_GRADIENT 1

#define GR_GRADIENT_MAXSTOPS 10

typedef struct {
    int     grd_ptype;              // type flag for pattern union
    int     grd_mode;               // gradient mode (linear or radial)
    GrColor grd_oper;               // bitblt mode (SET, OR, XOR, AND, IMAGE)
    int     grd_memflags;           // set if dynamically allocated
    union {
        GrGrdLinearData grd_ld;     // linear data
        GrGrdRadialData grd_rd;     // radial data
    };
    int     grd_nstops;             // num of stops
    GrGrdStop grd_stop[GR_GRADIENT_MAXSTOPS];   // stop definition
    int     grd_genctbl;            // color table has been generated 1=yes 0=no
    GrColor grd_ctbl[257];          // color table ctbl[0]=num_colors=256 ever
} GrGradient;

/*
 * Fill pattern union -- can either be a bitmap, a pixmap or a gradient
 */
typedef union _GR_pattern {
    int        gp_ptype;            /* type flag */
    GrBitmap   gp_bitmap;           /* fill bitmap */
    GrPixmap   gp_pixmap;           /* fill pixmap */
    GrGradient gp_gradient;         /* fill gradient */
} GrPattern;
</pre>
<p>&nbsp;&nbsp;This define group (from <b>mgrx.h</b>) help to acces the
<code>GrPattern</code> menbers:
<pre>
#define gp_bmp_data                 gp_bitmap.bmp_data
#define gp_bmp_height               gp_bitmap.bmp_height
#define gp_bmp_fgcolor              gp_bitmap.bmp_fgcolor
#define gp_bmp_bgcolor              gp_bitmap.bmp_bgcolor

#define gp_pxp_width                gp_pixmap.pxp_width
#define gp_pxp_height               gp_pixmap.pxp_height
#define gp_pxp_oper                 gp_pixmap.pxp_oper
#define gp_pxp_source               gp_pixmap.pxp_source

#define gp_grd_mode                 gp_gradient.grd_mode
#define gp_grd_oper                 gp_gradient.grd_oper
#define gp_grd_memflags             gp_gradient.grd_memflags
#define gp_grd_ld                   gp_gradient.grd_ld
#define gp_grd_rd                   gp_gradient.grd_rd
#define gp_grd_nstops               gp_gradient.grd_nstops
#define gp_grd_stop                 gp_gradient.grd_stop
#define gp_grd_genctbl              gp_gradient.grd_genctbl
#define gp_grd_ctbl                 gp_gradient.grd_ctbl
</pre>

<h3>Bitmaps</h3>

<p>&nbsp;&nbsp;Bitmap patterns can be easily built from initialized character
arrays and static structures by the C compiler, thus no special support is
included in the library for creating them. The only action required from the
application program might be changing the foreground and background colors
as needed. Here is an example:

<pre>
    unsigned char bmpdata[8] = {0x00, 0x7E, 0x82, 0x82, 0x82, 0x82, 0x7E, 0x00};
    GrBitmap bm1 = {GR_PTYPE_BITMAP, 8, NULL, 0, 0, 0};
    bm1.bmp_fgcolor = GrWhite();
    bm1.bmp_bgcolor = GrBlack();
    bm1.bmp_data = (char *)bmpdata;
</pre>

<h3>Pixmaps</h3>

<p>&nbsp;&nbsp;Pixmap patterns are more difficult to build as they replicate the
layout of the video memory which changes for different video modes. For this
reason the library provides three functions to create pixmap patterns in a
mode-independent way:
<pre>
GrPattern *GrBuildPixmap(const char *pixels,int w,int h,const GrColorTableP ct);
GrPattern *GrBuildPixmapNR(const char *pixels,int w,int h,const GrColorTableP ct);
GrPattern *GrBuildPixmapFromBits(const char *bits,int w,int h,
                                 GrColor fgc,GrColor bgc);
GrPattern *GrBuildPixmapFromBitsNR(const char *bits,int w,int h,
                                   GrColor fgc,GrColor bgc);
GrPattern *GrConvertToPixmap(GrContext *src);
</pre>
<p>&nbsp;&nbsp;<code>GrBuildPixmap</code> build a pixmap from a two
dimensional (<code>w</code> by <code>h</code>) array of characters. The
elements in this array are used as indices into the color table specified
with the argument <code>ct</code>. (This means that pixmaps created
this way can use at most 256 colors.) The color table pointer:
<pre>
typedef GrColor *GrColorTableP;
</pre>
<p>should point to an array of integers with the first element being the
number of colors in the table and the color values themselves starting
with the second element. NOTE: any color modifiers (GrXOR, GrOR, GrAND)
OR-ed to the elements of the color table are ignored.

<p>&nbsp;&nbsp;The <code>GrBuildPixmapFromBits</code> function builds a
pixmap fill pattern from bitmap data. It is useful if the width of the
bitmap pattern is not eight as such bitmap patterns can not be used to build
a <code>GrBitmap</code> structure.

<p>&nbsp;&nbsp;Either <code>GrBuildPixmapFromBits</code> and
<code>GrBuildPixmap</code> can return a pixmap wither than <code>w</code>
to a multiple of 8 bytes for faster bitblt's. If that conduct is not
desirable use the NR versions of the fucntions.

<p>&nbsp;&nbsp;The <code>GrConvertToPixmap</code> function converts a
graphics context to a pixmap fill pattern. It is useful when the pattern
can be created with graphics drawing operations. NOTE: the pixmap pattern
and the original context share the drawing RAM, thus if the context is
redrawn the fill pattern changes as well.

<h3>Gradients</h3>

<p>&nbsp;&nbsp;Gradients can be build by simple code or using functions
from the library. First you call one of these:
<pre>
GrPattern *GrCreateLinGradient(int xi, int yi, int xf, int yf);
GrPattern *GrCreateRadGradient(int xc, int yc, int r);
</pre>
<p>to create a linear or a radial gradient. After that you define the 
gradient stop points using:
<pre>
int GrAddGradientStop(GrPattern *p, int dist, GrColor c);
</pre>
<p><code>dist</code> is a integer normalized distance, from 0 to 255, that
represent the distance from (x1,yi) to (xf,yf) or (r). Here is an simple
example for a radial gradient with 3 stop points:
<pre>
    rg1 = GrCreateRadGradient(GrMaxX()/2, GrMaxY()/2, GrMaxX()/2);
    if (rg1 == NULL) goto error;
    GrAddGradientStop(rg1, 0, GrAllocColor(255, 0, 0));
    GrAddGradientStop(rg1, 128, GrAllocColor(0, 0, 255));
    GrAddGradientStop(rg1, 255, GrAllocColor(0, 255, 0));
    GrGenGradientColorTbl(rg1);
</pre>
<p>&nbsp;&nbsp;In any case, after creating the gradient you must call
a function to populate the color table that defines the gradient:
<pre>
int GrGenGradientColorTbl(GrPattern *p);
</pre>

<p>&nbsp;&nbsp;When drawing with a gradient, the lib must calculate the 
distance to show the correct color for every point. If you want the same
gradient a lot of times is faster to generate first a pixmap from the gradient:
<pre>
GrPattern *GrBuildPixmapFromGradient(GrPattern *p, int xo, int yo, int w, int h);
</pre>
<p><code>w,h</code> will be the pixmap dimensions, and <code>xo,yo</code> the 
gradient pos that will correspond to the 0,0 pixmap point.

<h3>Destroy patterns</h3>

<p>&nbsp;&nbsp;Patterns which were built by library routines can be destroyed
when no longer needed (i.e. the space occupied by them can be freed) by calling:
<pre>
void GrDestroyPattern(GrPattern *p);
</pre>
<p>&nbsp;&nbsp;NOTE: when pixmap patterns converted from contexts are
destroyed, the drawing RAM is not freed. It is freed when the original
context is destroyed. Fill patterns built by the application have to be
destroyed by the application as well (if this is needed).

<hr>
<h2><a name="pfgpri">Pattern filled graphics primitives</a></h2>

<p>&nbsp;&nbsp;The list of supported pattern filled graphics primitives is
shown below. These functions are very similar to their solid filled
counterparts, only their last argument is different:
<pre>
void GrPatternFilledPlot(int x,int y,GrPattern *p);
void GrPatternFilledLine(int x1,int y1,int x2,int y2,GrPattern *p);
void GrPatternFilledBox(int x1,int y1,int x2,int y2,GrPattern *p);
void GrPatternFilledCircle(int xc,int yc,int r,GrPattern *p);
void GrPatternFilledEllipse(int xc,int yc,int xa,int ya,GrPattern *p);
void GrPatternFilledCircleArc(int xc,int yc,int r,int start,int end,
                              int style,GrPattern *p);
void GrPatternFilledEllipseArc(int xc,int yc,int xa,int ya,int start,int end,
                               int style,GrPattern *p);
void GrPatternFilledConvexPolygon(int numpts,int points[][2],GrPattern *p);
void GrPatternFilledPolygon(int numpts,int points[][2],GrPattern *p);
void GrPatternFloodFill(int x, int y, GrColor border, GrPattern *p);
</pre>
<p>&nbsp;&nbsp;All the above functions align the pattern origin with the 
context origin. Most of the time it is what is expected, so two intersecting
shapes show a continuous pattern. But some times it is needing to align to
other point, next functions do that:
<pre>
void GrPatAlignFilledPlot(int xo,int yo,int x,int y,GrPattern *p);
void GrPatAlignFilledLine(int xo,int yo,int x1,int y1,int x2,int y2,GrPattern *p);
void GrPatAlignFilledBox(int xo,int yo,int x1,int y1,int x2,int y2,GrPattern *p);
void GrPatAlignFilledCircle(int xo,int yo,int xc,int yc,int r,GrPattern *p);
void GrPatAlignFilledEllipse(int xo,int yo,int xc,int yc,int xa,int ya,GrPattern *p);
void GrPatAlignFilledCircleArc(int xo,int yo,int xc,int yc,int r,
                               int start,int end,int style,GrPattern *p);
void GrPatAlignFilledEllipseArc(int xo,int yo,int xc,int yc,int xa,int ya,
                                int start,int end,int style,GrPattern *p);
void GrPatAlignFilledConvexPolygon(int xo,int yo,int n,int pt[][2],GrPattern *p);
void GrPatAlignFilledPolygon(int xo,int yo,int n,int pt[][2],GrPattern *p);
void GrPatAlignFloodFill(int xo,int yo,int x, int y, GrColor border, GrPattern *p);
</pre>


<p>&nbsp;&nbsp;There are two functions to display all or part of a pixmap
in the current context, aligning to the display box:
<pre>
void GrPixmapDisplay(int x,int y, GrPixmap *p);
void GrPixmapDisplayExt(int x1,int y1,int x2,int y2, GrPixmap *p);
</pre>
<p>&nbsp;&nbsp;And two others to transform pixmaps:
<pre>
GrPixmap *GrPixmapInverse(GrPixmap *p,int flag);
GrPixmap *GrPixmapStretch(GrPixmap *p,int nwidth,int nheight);
</pre>
<p><code>GrPixmapInverse</code> creates a new pixmap
flipping <code>p</code> left-right or top-down as indicated by <code>flag
</code> that can be:
<pre>
#define GR_PIXMAP_INVLR  0x01  /* inverse left right */
#define GR_PIXMAP_INVTD  0x02  /* inverse top down */
</pre>
<p><code>GrPixmapStretch</code> creates a new pixmap stretching
<code>p</code> to <code>nwidth</code> by <code>nheight</code>.

<hr>
<h2><a name="pld">Patterned line drawing</a></h2>

<p>&nbsp;&nbsp;The custom line drawing functions introduced above also have
a version when the drawn sections can be filled with a (pixmap or bitmap)
fill pattern. To achieve this these functions must be passed both a custom
line drawing option (<code>GrLineOption</code> structure) and a fill pattern
(<code>GrPattern</code> union). These two have been combined into the
<code>GrLinePattern</code> structure:
<pre>
typedef struct {
  GrPattern     *lnp_pattern;    /* fill pattern */
  GrLineOption  *lnp_option;     /* width + dash pattern */
} GrLinePattern;
</pre>
<p>&nbsp;&nbsp;All patterned line drawing functions take a pointer to this
structure as their last argument. The list of available functions:
<pre>
void GrPatternedLine(int x1,int y1,int x2,int y2,GrLinePattern *lp);
void GrPatternedBox(int x1,int y1,int x2,int y2,GrLinePattern *lp);
void GrPatternedCircle(int xc,int yc,int r,GrLinePattern *lp);
void GrPatternedEllipse(int xc,int yc,int xa,int ya,GrLinePattern *lp);
void GrPatternedCircleArc(int xc,int yc,int r,int start,int end,
                          int style,GrLinePattern *lp);
void GrPatternedEllipseArc(int xc,int yc,int xa,int ya,int start,int end,
                           int style,GrLinePattern *lp);
void GrPatternedPolyLine(int numpts,int points[][2],GrLinePattern *lp);
void GrPatternedPolygon(int numpts,int points[][2],GrLinePattern *lp);
</pre>
<p>&nbsp;&nbsp;Again the above functions align the pattern origin with the 
context origin. To align with another point use next functions:
<pre>
void GrPatndAlignLine(int xo,int yo,int x1,int y1,int x2,int y2,GrLinePattern *lp);
void GrPatndAlignBox(int xo,int yo,int x1,int y1,int x2,int y2,GrLinePattern *lp);
void GrPatndAlignCircle(int xo,int yo,int xc,int yc,int r,GrLinePattern *lp);
void GrPatndAlignEllipse(int xo,int yo,int xc,int yc,int xa,int ya,GrLinePattern *lp);
void GrPatndAlignCircleArc(int xo,int yo,int xc,int yc,int r,
                           int start,int end,int style,GrLinePattern *lp);
void GrPatndAlignEllipseArc(int xo,int yo,int xc,int yc,int xa,int ya,
                            int start,int end,int style,GrLinePattern *lp);
void GrPatndAlignPolyLine(int xo,int yo,int numpts,int points[][2],GrLinePattern *lp);
void GrPatndAlignPolygon(int xo,int yo,int numpts,int points[][2],GrLinePattern *lp);
</pre>

<hr>
<h2><a name="enc">About text encoding</a></h2>

<p>&nbsp;&nbsp;If you use only ASCII text you can skip this chapter, set
the <code>chrtype</code> to <code>GR_BYTE_TEXT</code> (see below) and go ahead.
But if you need to use extended chars you need to know abour character
encodings. <b>MGRX</b> has (limited) support for extended encodings.

<p>&nbsp;&nbsp;The problem is that you can have different encodings for your
source code, for the fonts you are using and for the machine your program is
finally running. To manage this <b>MGRX</b> has four concepts:

<ul>
<li>User encoding.
<li>Font encoding.
<li>Chrtype (string encoding).
<li>KbSys encoding.
</ul>

<p>&nbsp;&nbsp;The <b>user encoding</b> is the source code encoding, The supported
encodings are:

<pre>
#define GRENC_CP437          0   /* standard DOS encoding */
#define GRENC_CP850          1   /* latin1 DOS encoding */
#define GRENC_CP1252         2   /* standard Win encoding */
#define GRENC_ISO_8859_1     3   /* standard in some Linux */
#define GRENC_UTF_8          4   /* multibyte unicode, standard in newest Linux */
#define GRENC_UCS_2          5   /* restricted unicode, 2 bytes, only BMP range */
#define GRENC_LASTENCODE     5   /* last encode, for checks */
</pre>

<b>MGRX</b> sets the user encoding to <code>GRENC_UTF_8</code> in linux
console and X11, to <code>GRENC_PC437</code> in DJGPP and to
<code>GRENC_PC1252</code> in Win32. But as a programmer you can know better
and can set it whit the <code>GrSetUserEncoding</code> function. Do it after
setting the graphics mode.

<pre>
int GrGetUserEncoding(void);
int GrSetUserEncoding(int enc);
</pre>

<p>&nbsp;&nbsp;The <b>font encoding</b> is obsviusly the encoding used by the font glyphs,
the supported font encodings are:

<pre>
#define GR_FONTENC_UNKNOWN     0     /* unknow encoding (no recode) */
#define GR_FONTENC_CP437       1     /* standard dos encoding */
#define GR_FONTENC_CP850       2     /* standard dos encoding */
#define GR_FONTENC_CP1252      3     /* standard Win encoding */
#define GR_FONTENC_ISO_8859_1  4     /* standard latin encoding */
#define GR_FONTENC_UNICODE     5     /* direct UNICODE encoding */
#define GR_FONTENC_MGRX512     6     /* custom MGRX 512 char encoding */
#define GR_FONTENC_ISO_8859_5  7     /* ASCII + Cyrillic */
#define GR_FONTENC_ISO_8859_7  8     /* ASCII + Greek */
#define GR_FONTENC_CP437EXT    9     /* CP437 + ISO-8859-1 + CP1252 */
#define GR_FONTENC_LASTENC     9     /* last encoding, for checks */
</pre>

<p>Only the fonts provided whit <b>MGRX</b> in his own format (.fnt) have the
font encoding set in their heading data, but after loading a font, you can set their
encoding with the <code>GrFontSetEncoding</code> function.

<pre>
void GrFontSetEncoding(GrFont *font,int fontencoding);
</pre>

<p>The MGRX512 font encoding is a specially crafted encoding used by some of the fonts
provided with <b>MGRX</b>. It has 512 glyphs covering Latin, Cyrilic and Greek and
some other miscellaneous glyphs. See the <b>doc/mgrx512.txt</b> file for more
information.

<p>The CP437EXT font encoding is another <b>MGRX</b> custom encoding that cover
CP437 + ISO8859-1 + CP1252 (by now) providing 323 glyphs. See the <b>doc/cp437ext.txt</b>
file for more information.

<p>&nbsp;&nbsp;<b>Chrtype</b> is the specific encoding used for the string you want
to draw, it can be one of these:

<pre>
#define GR_BYTE_TEXT            0   /* 1 byte per character, unknow encoding */
#define GR_WORD_TEXT            1   /* 2 bytes per character, unknow encoding */
#define GR_CP437_TEXT           2   /* 1 bpc standard DOS encoding */
#define GR_CP850_TEXT           3   /* 1 bpc latin1 DOS encoding */
#define GR_CP1252_TEXT          4   /* 1 bpc standard Win encoding */
#define GR_ISO_8859_1_TEXT      5   /* 1 bpc latin1 standard in some Linux */
#define GR_UTF8_TEXT            6   /* multibyte UTF-8 Unicode, restricted to 4 bytes */
#define GR_UCS2_TEXT            7   /* 2 bpc restricted Unicode, only BMP range */
</pre>

<p>You can set the chrtype individually for every string you need to draw,
there is a funtion to get the chrtype corresponding to the user encoding

<pre>
char GrGetChrtypeForUserEncoding(void);
</pre>

<p>It takes advantage that the corresponding chtype is "userencoding + 2" so have
these into account if you want to add more encodings to <b>MGRX</b>.

<p>The <b>MGRX</b> text draw funtions will try to recode from chrtype to the
font encoding before draw the text.

<p>&nbsp;&nbsp;The <b>KbSys encoding</b> is the encoding used by the computer, where
the program is executed, to get input from the keyboard. It can be one of the defined
"user encoding". 

<p>Every input driver try to guess the encoding used for the running program,
if not sure it uses the MGRXKBSYSENCODING environment variable that can
be set by the users to one of these strings: "CP437", "CP850", "CP1252",
"ISO_8859_1", "UTF_8" or "UCS_2". The system encoding can be get using
this function:

<pre>
int GrGetKbSysEncoding(void);
</pre>

<p>If the KbSys encoding is different from the user encoding, the input driver will
recode key events to user encoding. So using by example 
<code>GrSetUserEncoding(GRENC_UTF_8);</code> you can write a portable
program that gets UTF8 encoded keys in every plattform.

<hr>
<h2><a name="td">Text drawing</a></h2>

<p>&nbsp;&nbsp;The library supports loadable fonts. When in memory they are
bit-mapped (i.e. not scalable!) fonts. A driver design allow <b>MGRX</b> to
load different font formats, the last <b>MGRX</b> release come with drivers
to load the <b>MGRX</b> own font format and the BGI Borland format for all
platforms supported, the X11 version can load X11 fonts too.

<p>&nbsp;&nbsp;The <b>MGRX</b> distribution come with a font collection in
the <b>MGRX</b> own format. Some of these fonts were converted from VGA fonts,
these fonts have all 256 characters from the CP437 or CP850 codepage. Some
fonts were converted from fonts in the MIT X11 distribution, these are ASCII
or ISO-8859-1 coded. A group of fonts were converted from the Terminus font
and are MGRX512 encoded. The following fonts are included:
<pre>
<b>Font file name       Family  Description</b>
pc&lt;W>x&lt;H>[t].fnt     pc      pc font, fixed, CP437
px&lt;W>x&lt;H>.fnt        pcext   pc font, fixed, CP437EXT
pc850-&lt;H>[t].fnt     pc      pc font, fixed, CP850
xm&lt;W>x&lt;H>[b][i].fnt  X_misc  X11, fixed, miscellaneous group, ASCII
char&lt;H>[b][i].fnt    char    X11, proportional, charter family, ISO-8859-1
cour&lt;H>[b][i].fnt    cour    X11, fixed, courier, ISO-8859-1
helv&lt;H>[b][i].fnt    helve   X11, proportional, helvetica, ISO-8859-1
lucb&lt;H>[b][i].fnt    lucb    X11, proportional, lucida bright, ISO-8859-1
lucs&lt;H>[b][i].fnt    lucs    X11, proportional, lucida sans serif , ISO-8859-1
luct&lt;H>[b][i].fnt    luct    X11, fixed, lucida typewriter, ISO-8859-1
ncen&lt;H>[b][i].fnt    ncen    X11, proportional, new century schoolbook, ISO-8859-1
symb&lt;H>.fnt          symbol  X11, proportional, greek letters, symbols 
tms&lt;H>[b][i].fnt     times   X11, proportional, times, ISO-8859-1
tmgrx&lt;H>[b].fnt      tmgrx   Ter, fixed, MGRX512
</pre>
<p>&nbsp;&nbsp;In the font names &lt;W> means the font width, &lt;H> the font
height. Many font families have bold and/or italic variants. The files
containing these fonts contain a 'b' and/or 'i' character in their name just
before the extension. Some of the pc fonts come in thin
formats also, these are denoted by a 't' in their file names.

<p>&nbsp;&nbsp;A full font list is in the <b>fonts/_fonts.dir</b> file. Please
read the <b>copying.grx</b> file to know about font licenses.

<p>&nbsp;&nbsp;The <code>GrFont</code> structure hold a font in memory. A
number of 'pc' fonts are built-in to the library and don't need to be
loaded:
<pre>
extern  GrFont          GrFont_PC6x8;
extern  GrFont          GrFont_PC8x8;
extern  GrFont          GrFont_PC8x14;
extern  GrFont          GrFont_PC8x16;
extern  GrFont          GrFont_PX8x18;
extern  GrFont          GrFont_PX11x22;
extern  GrFont          GrFont_PX14x28;
</pre>

<p>The first four are CP437 coded and the last three CP437EXT.

<p>&nbsp;&nbsp;Other fonts must be loaded with the <code>GrLoadFont</code>
function. If the font file name starts with any path separator character
or character sequence ('<drive letter>:', '/' or '\') then it is loaded
from the specified directory, otherwise the library try load the font first
from the current directory and next from the default font path. The font
path can be set up with the <code>GrSetFontPath</code> function. If the font
path is not set then the value of the 'GRXFONT' environment variable is used
as the font path. If <code>GrLoadFont</code> is called again with the name
of an already loaded font then it will return a pointer to the result of the
first loading. Font loading routines return NULL if the font was not found.
When not needed any more, fonts can be unloaded (i.e. the storage occupied
by them freed) by calling <code>GrUnloadFont</code>.

<p>&nbsp;&nbsp;The prototype declarations for these functions:
<pre>
GrFont *GrLoadFont(char *name);
void GrUnloadFont(GrFont *font);
void GrSetFontPath(char *path_list);
</pre>
<p>&nbsp;&nbsp;Using these functions:
<pre>
GrFont *GrLoadConvertedFont(char *name,int cvt,int w,int h,
                            int minch,int maxch);
GrFont *GrBuildConvertedFont(const GrFont *from,int cvt,int w,int h,
                             int minch,int maxch);
</pre>
<p>a new font can be generated from a file font or a font in memory, the
'cvt' argument direct the conversion or-ing the desired operations from
these defines:
<pre>
/*
 * Font conversion flags for 'GrLoadConvertedFont'. OR them as desired.
 */
#define GR_FONTCVT_NONE         0     /* no conversion */
#define GR_FONTCVT_SKIPCHARS    1     /* load only selected characters */
#define GR_FONTCVT_RESIZE       2     /* resize the font */
#define GR_FONTCVT_ITALICIZE    4     /* tilt font for "italic" look */
#define GR_FONTCVT_BOLDIFY      8     /* make a "bold"(er) font  */
#define GR_FONTCVT_FIXIFY       16    /* convert prop. font to fixed wdt */
#define GR_FONTCVT_PROPORTION   32    /* convert fixed font to prop. wdt */
</pre>
<p>&nbsp;&nbsp;<code>GR_FONTCVT_SKIPCHARS</code> needs 'minch' and 'maxch'
arguments.
<p>&nbsp;&nbsp;<code>GR_FONTCVT_RESIZE</code> needs 'w' and 'h' arguments.

<p>&nbsp;&nbsp;The function:
<pre>
int GrDumpGrxFont(const GrFont *f, char *fileName);
</pre>
<p>writes a font to a file int the <b>MGRX</b> own format. It returns 0
if error or 1 if succes.

<p>&nbsp;&nbsp;The function:
<pre>
int GrDumpFnaFont(const GrFont *f, char *fileName);
</pre>
<p>writes a font to an ascii font file, so it can be quickly edited with a
text editor. For a description of the ascii font format, see the
<b>doc/fna.txt</b> file.  It returns 0 if error or 1 if succes.

<p>&nbsp;&nbsp;The function:
<pre>
int GrDumpFont(const GrFont *f,char *CsymbolName,char *fileName);
</pre>
<p>writes a font to a C source code file, so it can be compiled and linked
with a user program. <code>GrDumpFont</code> would not normally be used in
a released program because its purpose is to produce source code. When the
source code is compiled and linked into a program distributing the font
file with the program is not necessary, avoiding the possibility of the
font file being deleted or corrupted.

<p>&nbsp;&nbsp;You can use the premade <b>src/utilprog/fnt2c.c</b> program
(see the source, it's so simple) to dump a selected font to source code,
by example:
<pre>
"fnt2c helv15 myhelv15.c myhelv15"
</pre>
<p>&nbsp;&nbsp;Next, if this line is included in your main include file:
<pre>
extern GrFont myhelv15
</pre>
<p>and "myhelv15.c" compiled and linked with your project, you can use
'myhelv15' in every place a <code>GrFont</code> is required.

<p>&nbsp;&nbsp;This simple function:
<pre>
void GrTextXY(int x,int y,char *text,GrColor fg,GrColor bg);
</pre>
<p>draw text in the current context in the standard direction, using the
Default Font (set initially to <code>GrFont_PC8x14</code> but can be changed),
using the <b>chrtype</b> corresponding to the user encoding, 
with <code>x</code>, <code>y</code> like the upper left corner and the
foreground and background colors given (note that <code>bg</code> equal
to <code>GrNOCOLOR</code> make the background transparent).

<p>the Default Font can be get or set with these functions:
<pre>
GrFont *GrGetDefaultFont();
void GrSetDefaultFont(GrFont *font);
</pre>

<p>&nbsp;&nbsp;For other functions the <code>GrTextOption</code> structure
specifies how to draw a character string:
<pre>
typedef struct _GR_textOption {  /* text drawing option structure */
        GrFont *txo_font;        /* font to be used */
        GrColor txo_fgcolor;     /* foreground color */
        GrColor txo_bgcolor;     /* background color */
        char    txo_chrtype;     /* character type (see above) */
        char    txo_direct;      /* direction (see above) */
        char    txo_xalign;      /* X alignment (see above) */
        char    txo_yalign;      /* Y alignment (see above) */
} GrTextOption;
</pre>
<p>&nbsp;&nbsp;The text can be rotated in increments of 90 degrees
(<code>txo_direct</code>), alignments can be set in both directions
(<code>txo_xalign</code> and <code>txo_yalign</code>), and separate
fore and background colors can be specified. The accepted text
direction values:
<pre>
#define GR_TEXT_RIGHT           0       /* normal */
#define GR_TEXT_DOWN            1       /* downward */
#define GR_TEXT_LEFT            2       /* upside down, right to left */
#define GR_TEXT_UP              3       /* upward */
#define GR_TEXT_DEFAULT         GR_TEXT_RIGHT
</pre>
<p>&nbsp;&nbsp;The accepted horizontal and vertical alignment option values:
<pre>
#define GR_ALIGN_LEFT           0       /* X only */
#define GR_ALIGN_TOP            0       /* Y only */
#define GR_ALIGN_CENTER         1       /* X, Y   */
#define GR_ALIGN_RIGHT          2       /* X only */
#define GR_ALIGN_BOTTOM         2       /* Y only */
#define GR_ALIGN_BASELINE       3       /* Y only */
#define GR_ALIGN_DEFAULT        GR_ALIGN_LEFT
</pre>
<p>&nbsp;&nbsp;Text strings chrtype must be one of the types defined in the 
previous section. With <code>GR_BYTE_TEXT</code> and <code>GR_WORD_TEXT</code>
there will be no recoding, so is up to you to select a font that match the
text encoding you are using.

<p>&nbsp;&nbsp;Remember that <code>GR_WORD_TEXT</code> and <code>GR_UCS2_TEXT</code>
are two bytes per character. <code>GR_UTF8_TEXT</code> is the standard multibyte
UTF-8 encoding. All other chrtypes are one byte per character.

<p>&nbsp;&nbsp;Text strings can also be drawn underlined. This is controlled
by OR-ing the constant <code>GR_UNDERLINE_TEXT</code> to the foreground color
value:
<pre>
#define GR_UNDERLINE_TEXT       (GrXOR << 4)
</pre>
<p>&nbsp;&nbsp;After the application initializes a text option structure
with the desired values it can call one of the following two text drawing
functions:
<pre>
void GrDrawChar(long chr,int x,int y,const GrTextOption *opt);
void GrDrawString(void *text,int length,int x,int y,const GrTextOption *opt);
</pre>

<p>&nbsp;&nbsp;You must set the <code>length</code> parameter according to
the indicated chrtype, it must be number of words for <code>GR_WORD_TEXT</code>
and <code>GR_UCS2_TEXT</code>, the real number of characters for
<code>GR_UTF8_TEXT</code>, or the number of bytes for the rest of chrtypes.
If the string is NULL terminated you can set <code>length</code> to 0, and the
function will calculate the lenght according to the chrtype.

<p>&nbsp;&nbsp;NOTE: text drawing is fastest when it is drawn in the 'normal'
direction, and the character does not have to be clipped. It this case the
library can use the appropriate low-level video RAM access routine, while
in any other case the text is drawn pixel-by-pixel by the higher-level code.

<p>&nbsp;&nbsp;There are pattern filed versions too:
<pre>
void GrPatternDrawChar(long chr,int x,int y,const GrTextOption *opt,GrPattern *p);
void GrPatternDrawString(void *text,int length,int x,int y,
                         const GrTextOption *opt,GrPattern *p);
void GrPatternDrawCharExt(long chr,int x,int y,const GrTextOption *opt,GrPattern *p);
void GrPatternDrawStringExt(void *text,int length,int x,int y,
                            const GrTextOption *opt,GrPattern *p);
</pre>
<p>the first two align the pattern origin with the context origin. The
last two align with the text box.

<p>&nbsp;&nbsp;The size of a font, a character or a text string can be
obtained by calling one of the following functions. These functions also
take into consideration the text direction specified in the text option
structure passed to them.
<pre>
int  GrFontCharPresent(const GrFont *font,int chr);
int  GrFontCharWidth(const GrFont *font,int chr);
int  GrFontCharHeight(const GrFont *font,int chr);
int  GrFontCharBmpRowSize(const GrFont *font,int chr);
int  GrFontCharBitmapSize(const GrFont *font,int chr);

int  GrFontStringWidth(const GrFont *font,void *text,int len,int chrtype);
int  GrFontStringHeight(const GrFont *font,void *text,int len,int chrtype);

int  GrCharWidth(long chr,const GrTextOption *opt);
int  GrCharHeight(long chr,const GrTextOption *opt);
void GrCharSize(long chr,const GrTextOption *opt,int *w,int *h);
int  GrStringWidth(void *text,int length,const GrTextOption *opt);
int  GrStringHeight(void *text,int length,const GrTextOption *opt);
void GrStringSize(void *text,int length,const GrTextOption *opt,int *w,int *h);
</pre>

<p>&nbsp;&nbsp;The first five funtions don't recode, so the <code>chr</code>
parameter is really the font glyph index. All other fucntions recode if needed.
If the string is NULL terminated you can set <code>length</code> to 0, and 
let the function calculate the lenght according to the chrtype.

<hr>
<h2><a name="utf8">Special UTF-8 text type considerations</a></h2>

<p>To deal with <code>GR_UTF8_TEXT</code>, <b>MGRX</b> provides some special
funtions:

<pre>
int GrUTF8StrLen(unsigned char *s);
</pre>
<p>returns the number of UTF-8 characters in <code>s</code>.

<pre>
int GrStrLen(const void *text, int chrtype);
</pre>
<p>is a more general function that returns the number of characters according
to the chrtype provided.

<pre>
long GrUCS2ToUTF8(unsigned short ch);
</pre>
<p>converts a UCS-2 word character to a UTF-8 string packed in a long
for convenience (some functions use it, see bellow).

<pre>
long GrNextUTF8Char(unsigned char *s, int *nb);
</pre>
<p>returns the first UTF-8 character packed in a long, it sets <code>nb</code>
to the number of bytes consumed, so you can advance the string pointer to the
next character.

<pre>
unsigned short GrUTF8ToUCS2(unsigned char *s);
</pre>
<p>converts the first UTF-8 character in <code>s</code> to a a UCS-2
word character.

<pre>
unsigned short *GrUTF8StrToUCS2Str(unsigned char *s, int *ulen, int maxlen);
</pre>
<p>converts a UTF-8 string to a UCS-2 string and set the <code>ulen</code>
variable with the UTF-8 string length. This function allocates the
necesary memory, so you must check the returned pointer for NULL, and the
memory must be freed when unneded. The <code>maxlen</code> parameter fixs
the maximum len you want, a 0 indicates no maxlen.

<p>For font related functions that expect a string and a length you must
pass the UTF-8 string and UTF-8 length (or less), example:

<pre>
opt.txo_chrtype = GR_UTF8_TEXT;
GrDrawString(sutf8, GrUTF8StrLen(sutf8), x, y, opt);
</pre>

<o>or if <code>sutf8</code> is NULL terminated you can let the fucntion
to calculate:

<pre>
opt.txo_chrtype = GR_UTF8_TEXT;
GrDrawString(sutf8, 0, x, y, opt);
</pre>


<p>For font related functions that expect a unique character packed in
a long and a chrtype, you need to pack the UTF-8 char in a long,
example:

<pre>
long *c;
char cutf8[4];
...
put in cutf8 the character;
c = (long *)&amp;cutf8;
opt.txo_chrtype = GR_UTF8_TEXT;
void GrDrawChar(*c, x, y, opt);
</pre>

<p>For font functions that expect a unique character without chrtype,
you must pass the UCS-2 equivalent character, example:

<pre>
GrFontCharWidth(font,GrUTF8ToUCS2(sutf8));
</pre>

<hr>
<h2><a name="ucs2">Recode to/from GR_UCS2_TEXT chartype</a></h2>

<p>&nbsp;&nbsp;GR_UCS2_TEXT chartype is a very convenient chartype to
work internally for a program, because it can accommodate every character
from other chartypes and any char occupies exactly two bytes (an unsigned
short). <b>MGRX</b> provides some funtions to recode to/from any chartype
(including the GR_UTF8_TEXT chartype) from/to GR_UCS2_TEXT.

<pre>
unsigned short GrCharRecodeToUCS2(long chr,int chrtype);
</pre>
<p>converts the <code>chr</code> character of type <code>chartype</code>
to a a UCS-2 character. Remember for UTF-8 you have to provide a char[4]
packed in a long.

<pre>
long GrCharRecodeFromUCS2(long chr,int chrtype);
</pre>
<p>do the opposite, converts a <code>chr</code> UCS-2 character to a 
character of type <code>chartype</code>. Again, if UTF-8 is the chartype
required, it returns a char[4] packed in a long.

<pre>
unsigned short *GrTextRecodeToUCS2(const void *text,int length,int chrtype);
</pre>
<p>converts a string of any <code>chartype</code> to a UCS-2 string. This
function allocates the necesary memory, so you must check the returned pointer
for NULL, and the memory must be freed when unneded.

<hr>
<h2><a name="i18n">Internationalization</a></h2>

<p>&nbsp;&nbsp;To help internationalize programs, <b>MGRX</b> includes a 
catalog implementation. It doesn't depend of any other <b>MGRX</b> function
and it is Chrtype agnostic (this is why (void *) is used to pass strings).

<p>These are the functions:

<pre>
int GrI18nInit(int nlg, int nstr, void *defstr);
void GrI18nEnd(void);
int GrI18nSetLabel(int lid, void *label);
void * GrI18nGetLabel(int lid);
int GrI18nSetLang(int lid);
void GrI18nAddStrings(int lid, int fsid, int nums, void **str);
void * GrI18nGetString(int sid);
</pre>

<p>For an example of use read the test program "test/i18ntest.c"

<hr>
<h2><a name="siuc">Drawing in user coordinates</a></h2>

<p>&nbsp;&nbsp;There is a second set of the graphics primitives which
operates in user coordinates. Every context has a user to screen coordinate
mapping associated with it. An application specifies the user window by
calling the <code>GrSetUserWindow</code> function.
<pre>
void GrSetUserWindow(int x1,int y1,int x2,int y2);
</pre>
<p>&nbsp;&nbsp;A call to this function it in fact specifies the virtual
coordinate limits which will be mapped onto the current context regardless
of the size of the context. For example, the call:
<pre>
GrSetUserWindow(0,0,11999,8999);
</pre>
<p>tells the library that the program will perform its drawing operations
in a coordinate system X:0...11999 (width = 12000) and Y:0...8999
(height = 9000). This coordinate range will be mapped onto the total area
of the current context. The virtual coordinate system can also be shifted.
For example:
<pre>
GrSetUserWindow(5000,2000,16999,10999);
</pre>
<p>&nbsp;&nbsp;The user coordinates can even be used to turn the usual
left-handed coordinate system (0:0 corresponds to the upper left corner)
to a right handed one (0:0 corresponds to the bottom left corner) by calling:
<pre>
GrSetUserWindow(0,8999,11999,0); 
</pre>
<p>&nbsp;&nbsp;The library also provides three utility functions for the
query of the current user coordinate limits and for converting user
coordinates to screen coordinates and vice versa.
<pre>
void GrGetUserWindow(int *x1,int *y1,int *x2,int *y2);
void GrGetScreenCoord(int *x,int *y);
void GrGetUserCoord(int *x,int *y);
</pre>
<p>&nbsp;&nbsp;If an application wants to take advantage of the user to
screen coordinate mapping it has to use the user coordinate version of
the graphics primitives. These have exactly the same parameter passing
conventions as their screen coordinate counterparts. NOTE: the user
coordinate system is not initialized by the library! The application has
to set up its coordinate mapping before calling any of the use coordinate
drawing functions -- otherwise the program will almost certainly exit
(in a quite ungraceful fashion) with a 'division by zero' error. The list
of supported user coordinate drawing functions:
<pre>
void GrUsrPlot(int x,int y,GrColor c);
void GrUsrLine(int x1,int y1,int x2,int y2,GrColor c);
void GrUsrHLine(int x1,int x2,int y,GrColor c);
void GrUsrVLine(int x,int y1,int y2,GrColor c);
void GrUsrBox(int x1,int y1,int x2,int y2,GrColor c);
void GrUsrFilledBox(int x1,int y1,int x2,int y2,GrColor c);
void GrUsrFramedBox(int x1,int y1,int x2,int y2,int wdt,GrFBoxColors *c);
void GrUsrCircle(int xc,int yc,int r,GrColor c);
void GrUsrEllipse(int xc,int yc,int xa,int ya,GrColor c);
void GrUsrCircleArc(int xc,int yc,int r,int start,int end,
                    int style,GrColor c);
void GrUsrEllipseArc(int xc,int yc,int xa,int ya,int start,int end,
                     int style,GrColor c);
void GrUsrFilledCircle(int xc,int yc,int r,GrColor c);
void GrUsrFilledEllipse(int xc,int yc,int xa,int ya,GrColor c);
void GrUsrFilledCircleArc(int xc,int yc,int r,int start,int end,
                          int style,GrColor c);
void GrUsrFilledEllipseArc(int xc,int yc,int xa,int ya,int start,int end,
                           int style,GrColor c);
void GrUsrPolyLine(int numpts,int points[][2],GrColor c);
void GrUsrPolygon(int numpts,int points[][2],GrColor c);
void GrUsrFilledConvexPolygon(int numpts,int points[][2],GrColor c);
void GrUsrFilledPolygon(int numpts,int points[][2],GrColor c);
void GrUsrFloodFill(int x, int y, GrColor border, GrColor c);

GrColor GrUsrPixel(int x,int y);
GrColor GrUsrPixelC(GrContext *c,int x,int y);

void GrUsrCustomLine(int x1,int y1,int x2,int y2,const GrLineOption *o);
void GrUsrCustomBox(int x1,int y1,int x2,int y2,const GrLineOption *o);
void GrUsrCustomCircle(int xc,int yc,int r,const GrLineOption *o);
void GrUsrCustomEllipse(int xc,int yc,int xa,int ya,const GrLineOption *o);
void GrUsrCustomCircleArc(int xc,int yc,int r,int start,int end,
                          int style,const GrLineOption *o);
void GrUsrCustomEllipseArc(int xc,int yc,int xa,int ya,int start,int end,
                           int style,const GrLineOption *o);
void GrUsrCustomPolyLine(int numpts,int points[][2],const GrLineOption *o);
void GrUsrCustomPolygon(int numpts,int points[][2],const GrLineOption *o);

void GrUsrPatternedLine(int x1,int y1,int x2,int y2,GrLinePattern *lp);
void GrUsrPatternedBox(int x1,int y1,int x2,int y2,GrLinePattern *lp);
void GrUsrPatternedCircle(int xc,int yc,int r,GrLinePattern *lp);
void GrUsrPatternedEllipse(int xc,int yc,int xa,int ya,GrLinePattern *lp);
void GrUsrPatternedCircleArc(int xc,int yc,int r,int start,int end,
                             int style,GrLinePattern *lp);
void GrUsrPatternedEllipseArc(int xc,int yc,int xa,int ya,int start,int end,
                              int style,GrLinePattern *lp);
void GrUsrPatternedPolyLine(int numpts,int points[][2],GrLinePattern *lp);
void GrUsrPatternedPolygon(int numpts,int points[][2],GrLinePattern *lp);

void GrUsrPatternFilledPlot(int x,int y,GrPattern *p);
void GrUsrPatternFilledLine(int x1,int y1,int x2,int y2,GrPattern *p);
void GrUsrPatternFilledBox(int x1,int y1,int x2,int y2,GrPattern *p);
void GrUsrPatternFilledCircle(int xc,int yc,int r,GrPattern *p);
void GrUsrPatternFilledEllipse(int xc,int yc,int xa,int ya,GrPattern *p);
void GrUsrPatternFilledCircleArc(int xc,int yc,int r,int start,int end,int style,GrPattern *p);
void GrUsrPatternFilledEllipseArc(int xc,int yc,int xa,int ya,int start,int end,int style,GrPattern *p);
void GrUsrPatternFilledConvexPolygon(int numpts,int points[][2],GrPattern *p);
void GrUsrPatternFilledPolygon(int numpts,int points[][2],GrPattern *p);
void GrUsrPatternFloodFill(int x, int y, GrColor border, GrPattern *p);

void GrUsrDrawChar(long chr,int x,int y,const GrTextOption *opt);
void GrUsrDrawString(char *text,int length,int x,int y,const GrTextOption *opt);
void GrUsrTextXY(int x,int y,char *text,GrColor fg,GrColor bg);
</pre>

<hr>
<h2><a name="gcur">Graphics cursors</a></h2>

<p>&nbsp;&nbsp;The library provides support for the creation and usage of an
unlimited number of graphics cursors. An application can use these cursors
for any purpose. Cursors always save the area they occupy before they are
drawn. When moved or erased they restore this area. As a general rule of
thumb, an application should erase a cursor before making changes to an
area it occupies and redraw the cursor after finishing the drawing. Cursors
are created with the <code>GrBuildCursor</code> function:
<pre>
GrCursor *GrBuildCursor(char *pixels,int pitch,int w,int h,
                        int xo,int yo,const GrColorTableP c);
</pre>
<p>&nbsp;&nbsp;The <code>pixels</code>, <code>w</code> (=width), <code>h</code>
(=height) and <code>c</code> (= color table) arguments are similar to the
arguments of the pixmap building library function <code>GrBuildPixmap</code>
(see that paragraph for a more detailed explanation.), but with two
differences. First, is not assumed that the pixels data is <code>w</code>
x <code>h</code> sized, the <code>pitch</code> argument set the offset
between rows. Second, the pixmap data is interpreted slightly differently,
any pixel with value zero is taken as a "transparent" pixel, i.e. the
background will show through the cursor pattern at that pixel. A pixmap
data byte with value = 1 will refer to the first color in the table, and so
on.

<p>&nbsp;&nbsp;The <code>xo</code> (= X offset) and <code>yo</code> (= Y
offset) arguments specify the position (from the top left corner of the
cursor pattern) of the cursor's "hot point".

<p>&nbsp;&nbsp;The <code>GrCursor</code> data structure:
<pre>
typedef struct _GR_cursor {
  struct _GR_context work;            /* work areas (4) */
  int     xcord,ycord;                /* cursor position on screen */
  int     xsize,ysize;                /* cursor size */
  int     xoffs,yoffs;                /* LU corner to hot point offset */
  int     xwork,ywork;                /* save/work area sizes */
  int     xwpos,ywpos;                /* save/work area position on screen */
  int     displayed;                  /* set if displayed */
} GrCursor;
</pre>
<p>is typically not used (i.e. read or changed) by the application program,
it should just pass pointers to these structures to the appropriate library
functions. Other cursor manipulation functions:
<pre>
void GrDisplayCursor(GrCursor *cursor);
void GrEraseCursor(GrCursor *cursor);
void GrMoveCursor(GrCursor *cursor,int x,int y);
void GrDestroyCursor(GrCursor *cursor);
</pre>

<hr>
<h2><a name="pnm">Writing/reading PNM graphics files</a></h2>

<p>&nbsp;&nbsp;<b>MGRX</b> includes functions to load/save a context
from/to a PNM file.

<p>&nbsp;&nbsp;PNM is a group of simple graphics formats from the
<a href="http://netpbm.sourceforge.net">NetPbm</a>
distribution. NetPbm can convert from/to PNM lots of graphics formats, and
apply some transformations to PNM files (Note. You don't need the NetPbm
distribution to use the MGRX functions).

<p>&nbsp;&nbsp;There are six PNM formats:

<ul>
<li>P1 text PBM (bitmap)
<li>P2 text PGM (gray scale)
<li>P3 text PPM (real color)
<li>P4 binary PBM (bitmap)
<li>P5 binary PGM (gray scale)
<li>P6 binary PPM (real color)
</ul>

<p>&nbsp;&nbsp;<b>MGRX</b> can handle the binary formats only (get the NetPbm
distribution if you need to convert text to binary formats).

<p>&nbsp;&nbsp;To save a context in a PNM file you have three functions:

<pre>
int GrSaveContextToPbm( GrContext *grc, char *pbmfn, char *docn );
int GrSaveContextToPgm( GrContext *grc, char *pgmfn, char *docn );
int GrSaveContextToPpm( GrContext *grc, char *ppmfn, char *docn );
</pre>

they work both in RGB and palette modes, <code>grc</code> must be
a pointer to the context to be saved, if it is NULL the current context is
saved; <code>p-mfn</code> is the file name to be created and
<code>docn</code> is an optional text comment to be written in the file,
it can be NULL. The functions return 0 on succes or -1 on error.

<p>&nbsp;&nbsp;<code>GrSaveContextToPbm</code> dumps a context in a PBM file
(bitmap). If the pixel color isn't Black it asumes White.

<p>&nbsp;&nbsp;<code>GrSaveContextToPgm</code> dumps a context in a PGM file
(gray scale). The colors are quantized to gray scale using .299r + .587g +
.114b.

<p>&nbsp;&nbsp;<code>GrSaveContextToPpm</code> dumps a context in a PPM file
(real color).

<p>&nbsp;&nbsp;To load a PNM file in a context you must use:

<pre>
int GrLoadContextFromPnm( GrContext *grc, char *pnmfn );
</pre>

it support reading PBM, PGM and PPM binary files. <code>grc</code> must
be a pointer to the context to be written, if it is NULL the current context
is used; <code>p-mfn</code> is the file name to be read. If context
dimensions are lesser than pnm dimensions, the function loads as much as it
can. If color mode is not in RGB mode, the routine allocates as much colors
as it can. The function returns 0 on succes or -1 on error.

<p>&nbsp;&nbsp;To query the file format, width and height of a PNM
file you can use:

<pre>
int GrQueryPnm( char *pnmfn, int *width, int *height, int *maxval );
</pre>

<code>pnmfn</code> is the name of pnm file; <code>width</code> returns the
pnm width; <code>height</code> returns the pnm height; <code>maxval</code>
returns the max color component value. The function returns 1 to 6 on success
(the PNM format) or -1 on error.

<p>&nbsp;&nbsp;The two next functions:

<pre>
int GrLoadContextFromPnmBuffer( GrContext *grc, const char *pnmbuf );
int GrQueryPnmBuffer( const char *pnmbuf, int *width, int *height, int *maxval );
</pre>

work like <code>GrLoadContextFromPnm</code> and
<code>GrQueryPnmBuffer</code>, but they get his input from a buffer instead
of a file. This way, pnm files can be embeded in a program (using the
src/utilprog/bin2c program by example).

<hr>
<h2><a name="png">Writing/reading PNG graphics files</a></h2>

<p>&nbsp;&nbsp;<b>MGRX</b> includes functions to load/save a context
from/to a png file. But note, for this purpose it needs the
<a href="http://www.libpng.org/pub/png/libpng.html">libpng</a> library,
and to enable the png support before make the <b>MGRX</b> lib.

<p>&nbsp;&nbsp;Use next function to save a context in a PNG file:

<pre>
int GrSaveContextToPng( GrContext *grc, char *pngfn );
</pre>

it works both in RGB and palette modes, <code>grc</code> must be
a pointer to the context to be saved, if it is NULL the current context is
saved; <code>pngfn</code> is the file name to be created.
The function returns 0 on succes or -1 on error.

<p>&nbsp;&nbsp;To load a PNG file in a context you must use:

<pre>
int GrLoadContextFromPng( GrContext *grc, char *pngfn, int use_alpha );
</pre>

<code>grc</code> must be a pointer to the context to be written, if it
is NULL the current context is used; <code>pngfn</code> is the file name
to be read; set <code>use_alpha</code> to 1 if you want to use the image
alpha channel (if available). If context dimensions are lesser than png
dimensions, the function loads as much as it can. If color mode is not
in RGB mode, the routine allocates as much colors as it can. The function
returns 0 on succes or -1 on error.

<p>&nbsp;&nbsp;To query the width and height of a PNG file you can use:

<pre>
int GrQueryPng( char *pngfn, int *width, int *height );
</pre>

<code>pngfn</code> is the name of png file; <code>width</code> returns the
png width; <code>height</code> returns the png height.
The function returns 0 on success or -1 on error.

<p>&nbsp;&nbsp;The function:

<pre>
int GrPngSupport( void );
</pre>

returns 1 if there is png support in the library, 0 otherwise. If there is
not support for png, dummy functions are added to the library, returning
error (-1) ever.

<hr>
<h2><a name="jpeg">Writing/reading JPEG graphics files</a></h2>

<p>&nbsp;&nbsp;<b>MGRX</b> includes functions to load/save a context
from/to a jpeg file. But note, for this purpose it needs the
<a href="http://www.ijg.org">libjpeg</a> library,
and to enable the jpeg support before make the <b>MGRX</b> lib.

<p>&nbsp;&nbsp;Use next function to save a context in a JPEG file:

<pre>
int GrSaveContextToJpeg( GrContext *grc, char *jpegfn, int quality );
</pre>

it works both in RGB and palette modes, <code>grc</code> must be
a pointer to the context to be saved, if it is NULL the current context is
saved; <code>jpegfn</code> is the file name to be created;
<code>quality</code> is a number between 1 and 100 to drive the compression
quality, use higher values for better quality (and bigger files), you can
use 75 as a standard value, normally a value between 50 and 95 is good.
The function returns 0 on succes or -1 on error.

<p>&nbsp;&nbsp;This function saves a context in a grayscale JPEG file:

<pre>
int GrSaveContextToGrayJpeg( GrContext *grc, char *jpegfn, int quality );
</pre>

parameters and return codes are like in <code>GrSaveContextToJpeg</code>.
The colors are quantized to gray scale using .299r + .587g + .114b.

<p>&nbsp;&nbsp;To load a JPEG file in a context you must use:

<pre>
int GrLoadContextFromJpeg( GrContext *grc, char *jpegfn, int scale );
</pre>

<code>grc</code> must be a pointer to the context to be written, if it
is NULL the current context is used; <code>jpegfn</code> is the file name
to be read; set <code>scale</code> to 1, 2, 4 or 8 to reduce the loaded
image to 1/1, 1/2, 1/4 or 1/8. If context dimensions are lesser than jpeg
dimensions, the function loads as much as it can. If color mode is not
in RGB mode, the routine allocates as much colors as it can. The function
returns 0 on succes or -1 on error.

<p>&nbsp;&nbsp;To query the width and height of a JPEG file you can use:

<pre>
int GrQueryJpeg( char *jpegfn, int *width, int *height );
</pre>

<code>jpegfn</code> is the name of jpeg file; <code>width</code> returns the
jpeg width; <code>height</code> returns the jpeg height.
The function returns 0 on success or -1 on error.

<p>&nbsp;&nbsp;The function:

<pre>
int GrJpegSupport( void );
</pre>

returns 1 if there is jpeg support in the library, 0 otherwise. If there is
not support for jpeg, dummy functions are added to the library, returning
error (-1) ever.

<hr>
<h2><a name="misc">Miscellaneous functions</a></h2>

<p>&nbsp;&nbsp;Here we will describe some miscellaneous functions.

<pre>
unsigned GrGetLibraryVersion(void);
</pre>
<p>&nbsp;&nbsp;<code>GrGetLibraryVersion</code> returns the <b>MGRX</b>
version API, like a hexadecimal coded number. By example 0x0090
means 0.9.0
Because <b>mgrx.h</b> defines the <code>MGRX_VERSION_API</code> macro, you
can check if both, the library and the include file, are in the same version
using <code>if( GrGetLibraryVersion() == MGRX_VERSION_API )</code>

<pre>
unsigned GrGetLibrarySystem(void);
</pre>
<p>&nbsp;&nbsp;This functions returns a unsigned integer identifing the
system you are working in. <b>mgrx.h</b> defines some macros you can use:

<pre>
/* these are the supported configurations: */
#define MGRX_VERSION_GCC_386_DJGPP       1       /* DJGPP v2 */
#define MGRX_VERSION_GCC_386_LINUX       2       /* console framebuffer i386 */
#define MGRX_VERSION_GCC_386_X11         3       /* X11 version i386 */
#define MGRX_VERSION_GCC_386_WIN32       4       /* WIN32 using Mingw32 */
#define MGRX_VERSION_GCC_X86_64_LINUX    5       /* console framebuffer x86_64 */
#define MGRX_VERSION_GCC_X86_64_X11      6       /* X11 version x86_64 */
#define MGRX_VERSION_GCC_ARM_LINUX       7       /* console framebuffer arm */
#define MGRX_VERSION_GCC_ARM_X11         8       /* X11 version arm */
</pre>

<pre>
void GrSetWindowTitle(char *title);
</pre>
<p>&nbsp;&nbsp;<code>GrSetWindowTitle</code> sets the main window title
in the X11 an Win32 versions. It does nothing in the DOS and
Linux-Console versions.

<pre>
void GrSleep(int msec);
</pre>
<p>&nbsp;&nbsp;This function stops the program execution for
<code>msec</code> miliseconds.

<pre>
GrContext *GrCreateFrameContext(GrFrameMode md,int w,int h,
           char *memory[4],GrContext *where);
</pre>
<p>&nbsp;&nbsp;This function is like <code>GrCreateContext</code>, except
that you can specify any valid memory frame mode, not only the Screen
associated frame mode. It can be used for special purposes (see <code>
GrBitBlt1bpp</code> for an example).

<pre>
void GrBitBlt1bpp(GrContext *dst,int dx,int dy,GrContext *src,
     int x1,int y1,int x2,int y2,GrColor fg,GrColor bg);
</pre>
<p>&nbsp;&nbsp;This special function does a bitblt from a 1bpp context (a
bitmap really),
using <code>fg</code> and <code>bg</code> like the color+opcode when bit=1
and bit=0 respectively. Here is an example:

<pre>
  pContext = GrCreateFrameContext(GR_frameRAM1, sizex, sizey, NULL, NULL);
  /* draw something (black and white) into the bitmap */
  GrSetContext(pContext);
  GrClearContext( GrBlack() );
  GrLine(0, 0, sizex-1, sizey-1, GrWhite());
  GrLine(0, sizey-1, sizex-1, 0, GrWhite());

  /* Put the bitmap into the screen */
  GrSetContext(NULL);
  fcolor = GrAllocColor( 255,0,0 );
  bcolor = GrAllocColor( 0,0,255 );
  GrBitBlt1bpp(NULL,x,y,pContext,0,0,sizex-1,sizey-1,fcolor,bcolor);
</pre>

<hr>
<h2><a name="input">Input API</a></h2>

<p>&nbsp;&nbsp;<b>MGRX</b> can handle platform independent input. The input API
is based on events and is totally diferent from the GRX input API.

<p>&nbsp;&nbsp;The input API must be inited after a graphics mode is set using
this function:

<pre>
int GrEventInit(void);
</pre>

<p>it returns true on success and init the keyboard and the mouse if one is found.
The input API must be uninited before the program ends or before set another
graphic mode whit this function:

<pre>
void GrEventUnInit(void);
</pre>

<p>&nbsp;&nbsp;The basic function to get an event is:

<pre>
void GrEventRead(GrEvent * ev);
</pre>

<p>the event structure is defined in <b>mgrx.h</b>

<pre>
ttypedef struct {
    int type;               /* event type */
    long time;              /* miliseconds */
    int kbstat;             /* kb status (count for GREV_EXPOSE) */
    union {                 /* GREV_KEY     GREV_MOUSE  GREV_MMOVE  GREV_EXPOSE */
      long p1;              /* key          subevent    but status  x           */
      unsigned char cp1[4]; /* for easy access to multibyte key (like UTF-8)    */
    };
    long p2;                /* type/nbytes  x           x           y           */
    long p3;                /* --           y           y           width       */
    long p4;                /* --           --          --          height      */
} GrEvent;
</pre>

<p><code>GrEventRead</code> returns inmediatelly with type=GREV_NULL if no event
is ready. The possible events are:

<pre>
#define GREV_NULL    0           /* no event */
#define GREV_KEY     1           /* key pressed, p1=GRXkey (char or gr_keycode), p2=type or nbytes */
#define GREV_MOUSE   2           /* mouse event, p1=subevent, p2=x, p3=y */
#define GREV_MMOVE   3           /* mouse move event, p1=buttons status, p2=x, p3=y */
#define GREV_PREKEY  4           /* key event before be recoded, internal event, users don't see it */
#define GREV_EXPOSE  5           /* a window area must be redraw (generated only if user requests it */
#define GREV_WMEND   6           /* window manager wants ending (generated only if user requests it */
#define GREV_USER    100         /* user event */
</pre>

<p>a programmer can define user type events with values >= GREV_USER. When the
event is GREV_KEY, <code>p1</code> has the character or key and <code>p2</code>
the number of bytes used by the character or <code>GRKEY_KEYCODE</code> if it
is a special keys. When the event is GREV_MOUSE, <code>p1</code> has the subevent:

<pre>
#define GRMOUSE_LB_PRESSED  1    /* Left button depressed */
#define GRMOUSE_MB_PRESSED  2    /* Middle button depressed */
#define GRMOUSE_RB_PRESSED  3    /* Right button depressed */
#define GRMOUSE_LB_RELEASED 4    /* Left button released */
#define GRMOUSE_MB_RELEASED 5    /* Middle button released */
#define GRMOUSE_RB_RELEASED 6    /* Rigth button released */
#define GRMOUSE_B4_PRESSED  7    /* Button 4 depressed (scroll wheel) */
#define GRMOUSE_B4_RELEASED 8    /* Button 4 released (scroll wheel) */
#define GRMOUSE_B5_PRESSED  9    /* Button 5 depressed (scroll wheel) */
#define GRMOUSE_B5_RELEASED 10   /* Button 5 released (scroll wheel) */
</pre>

<p>&nbsp;&nbsp;By default <b>MGRX</b> doesn't generate GREV_MMOVE events except if
the programmer requests it with the function:

<pre>
void GrEventGenMmove(int when);
</pre>

<p><code>when</code> can be one of these constants:

<pre>
#define GR_GEN_MMOVE_NEVER  0    /* Doesn't gen GREV_MMOVE */
#define GR_GEN_MMOVE_IFBUT  1    /* Gen GREV_MMOVE if a button is pressed */
#define GR_GEN_MMOVE_ALWAYS 2    /* Gen GREV_MMOVE always */
</pre>

<p>for GREV_MMOVE <code>p1</code> is filled with the mouse buttons status:

<pre>
#define GRMOUSE_LB_STATUS   1    /* Status bit for left button */
#define GRMOUSE_MB_STATUS   4    /* Status bit for middle button */
#define GRMOUSE_RB_STATUS   2    /* Status bit for right button */
</pre>

<p>&nbsp;&nbsp;For GREV_KEY, GREV_MOUSE and GREV_MMOVE <code>kbstat</code> is filled
wih the keyboard status word, or-ing it with the next defines it can be
known the status of some special keys:

<pre>
#define GRKBS_RIGHTSHIFT    0x01   /* Keybd states: right shift key depressed */
#define GRKBS_LEFTSHIFT     0x02   /* left shift key depressed */
#define GRKBS_CTRL          0x04   /* CTRL depressed */
#define GRKBS_ALT           0x08   /* ALT depressed */
#define GRKBS_SCROLLOCK     0x10   /* SCROLL LOCK active */
#define GRKBS_NUMLOCK       0x20   /* NUM LOCK active */
#define GRKBS_CAPSLOCK      0x40   /* CAPS LOCK active */
#define GRKBS_INSERT        0x80   /* INSERT state active */
#define GRKBS_SHIFT         (GRKBS_LEFTSHIFT | GRKBS_RIGHTSHIFT)
</pre>

<p>&nbsp;&nbsp;The file <b>mgrxkeys.h</b> defines the keys returned in <code>p1</code> with
the GREV_KEY. This is an extract:

<pre>
#define GrKey_Control_A            0x0001
#define GrKey_Control_B            0x0002
#define GrKey_Control_C            0x0003
...
#define GrKey_A                    0x0041
#define GrKey_B                    0x0042
#define GrKey_C                    0x0043
...
#define GrKey_F1                   0x013b
#define GrKey_F2                   0x013c
#define GrKey_F3                   0x013d
...
#define GrKey_Alt_F1               0x0168
#define GrKey_Alt_F2               0x0169
#define GrKey_Alt_F3               0x016a
</pre>

<p>but you can be confident that the standard ASCII is right maped. Remenber,
if the KbSys encoding is different from the user encoding, the input driver
will recode key events to user encoding.

<p>&nbsp;&nbsp;The GREV_EXPOSE event is only generated in X11 systems and
only if the user requests it using this function:

<pre>
void GrEventGenExpose(int when);
</pre>

<p><code>when</code> can be:

<pre>
#define GR_GEN_EXPOSE_NO    0    /* Doesn't gen GREV_EXPOSE (default) */
#define GR_GEN_EXPOSE_YES   1    /* Gen GREV_EXPOSE */
</pre>

<p>When GREV_EXPOSE events are generated, the X11 video driver doesn't use
backing store, so drawings are faster, but the program must redraw the area
exposed by itsel. Check the test program "life" for an example. For systems
other than X11 the function does nothing. GREV_EXPOSE populates "count" in
the "kbstat" field. If count is zero, no more Expose events follow. Simple
applications that do not want to optimize redisplay can just ignore all
Expose events with nonzero counts and perform full redisplays on events with
zero counts. 

<p>&nbsp;&nbsp;The GREV_WMEND event is only generated in X11 and W32 systems
and only if the user requests it using this function:

<pre>
void GrEventGenWMEnd(int when);
</pre>

<p><code>when</code> can be:

<pre>
#define GR_GEN_WMEND_NO    0    /* Doesn't gen GREV_WMEND (default) */
#define GR_GEN_WMEND_YES   1    /* Gen GREV_WMEND */
</pre>

<p>If GREV_WMEND generation is active it will be generated when the user
click the close window button, then the program must handle it, normally
asking the user if he wants to exit. If generation is not active the
program will be aborted.

<p>&nbsp;&nbsp;These are the other functions of the input API:

<pre>
void GrEventFlush(void);
int GrEventCheck(void);
void GrEventWait(GrEvent * ev);
void GrEventWaitKeyOrClick(GrEvent * ev);
int GrEventEnqueue(GrEvent * ev);
int GrEventParEnqueue(int type, long p1, long p2, long p3, long p4);
int GrEventEnqueueFirst(GrEvent * ev);
int GrEventParEnqueueFirst(int type, long p1, long p2, long p3, long p4);
</pre>

<p><code>GrEventFlush</code> flush the event queue.

<p><code>GrEventCheck</code> returns true if an event is waiting.

<p><code>GrEventWait</code> waits until an event is ready.

<p><code>GrEventWaitKeyOrClick</code> waits until a key or the left mouse
button is pressed.

<p><code>GrEventEnqueue</code> and <code>GrEventParEnqueue</code> enqueue an
user event, passing the whole structure or only the type and parameters.

<p><code>GrEventEnqueueFirst</code> and <code>GrEventParEnqueueFirst</code> 
enqueue an user event at the begining of the queue.

<hr>
<h2><a name="mouse">Mouse cursor handling</a></h2>

<p>&nbsp;&nbsp;After the input API is initiated an application can test
whether a mouse is available by calling the function:
<pre>
int  GrMouseDetect(void);
</pre>
<p>which will return zero if no mouse (or mouse driver) is present, non-zero
otherwise.

<p>&nbsp;&nbsp;The mouse can be controlled with the following functions:
<pre>
void GrMouseSetSpeed(int spmult,int spdiv);
void GrMouseSetAccel(int thresh,int accel);
void GrMouseSetLimits(int x1,int y1,int x2,int y2);
void GrMouseGetLimits(int *x1,int *y1,int *x2,int *y2);
void GrMouseWarp(int x,int y);
</pre>

<p>&nbsp;&nbsp;For DOS and linux console the library calculates the mouse
position only from the mouse
mickey counters. (To avoid the limit and 'rounding to the next multiple of
eight' problem with some mouse driver when it finds itself in a graphics
mode unknown to it.) The parameters to the <code>GrMouseSetSpeed</code>
function specify how coordinate changes are obtained from mickey counter
changes, multipling by <code>spmult</code> and dividing by <code>spdiv</code>.
In high resolution graphics modes the value of one just works fine, in low
resolution modes (320x200 or similar) it is best set the <code>spdiv</code>
to two or three. (Of course, it also depends on the sensitivity the mouse.)
The <code>GrMouseSetAccel</code> function is used to control the ballistic
effect: if a mouse coordinate changes between two samplings by more than
the <code>thresh</code> parameter, the change is multiplied by the
<code>accel</code> parameter. NOTE: some mouse drivers perform similar
calculations before reporting the coordinates in mickeys. In this case the
acceleration done by the library will be additional to the one already
performed by the mouse driver.

<p>&nbsp;&nbsp;The limits of the mouse movement can be set
(passed limits will be clipped to the screen) with <code>GrMouseSetLimits
</code> (default is the whole screen) and the current limits can be obtained
with <code>GrMouseGetLimits</code>. <code>GrMouseWarp</code> sets the mouse
cursor to the specified position.

<p>&nbsp;&nbsp;As typical mouse drivers do not know how to draw mouse cursors
in high resolution graphics modes, the mouse cursor is drawn by the library.
The mouse cursor can be set with:
<pre>
void GrMouseSetCursor(GrCursor *cursor);
void GrMouseSetInternalCursor(int type,GrColor fg,GrColor bg);
</pre>
<p>&nbsp;&nbsp;<code>GrMouseSetInternalCursor</code> uses one of the available
internal cursors:
<pre>
#define GR_MCUR_TYPE_ARROW  0      /* MOUSE CURSOR types: arrow cursor */
#define GR_MCUR_TYPE_CROSS  1      /* cross cursor */
</pre>

<p>the color <code>fg</code> will be used as the interior of it and <code>bg
</code> will be the border. The current mouse cursor can be obtained with:
<pre>
GrCursor *GrMouseGetCursor(void);
</pre>
<p>&nbsp;&nbsp;The mouse cursor can be displayed/erased with:
<pre>
void GrMouseDisplayCursor(void);
void GrMouseEraseCursor(void);
</pre>
<p>&nbsp;&nbsp;The mouse cursor can be left permanently displayed. All
graphics primitives except for the few non-clipping functions check for
conflicts with the mouse cursor and erase it before the drawing if necessary.
Of course, it may be more efficient to erase the cursor manually before a
long drawing sequence and redraw it after completion. The library provides
an alternative pair of calls for this purpose which will erase the cursor
only if it interferes with the drawing:
<pre>
int  GrMouseBlock(GrContext *c,int x1,int y1,int x2,int y2);
void GrMouseUnBlock(int return_value_from_GrMouseBlock);
</pre>
<p>&nbsp;&nbsp;<code>GrMouseBlock</code> should be passed the context in
which the drawing will take place (the usual convention of NULL meaning the
current context is supported) and the limits of the affected area. It will
erase the cursor only if it interferes with the drawing. When the drawing
is finished <code>GrMouseUnBlock</code> must be called with the argument
returned by <code>GrMouseBlock</code>.

<p>&nbsp;&nbsp;The status of the mouse cursor can be obtained with calling
<code>GrMouseCursorIsDisplayed</code>. This function will return non-zero
if the cursor is displayed, zero if it is erased.
<pre>
int  GrMouseCursorIsDisplayed(void);
</pre>
<p>&nbsp;&nbsp;The library supports (beside the simple cursor drawing) three
types of "rubberband" attached to the mouse cursor. The <code>
GrMouseSetCursorMode</code> function is used to select the cursor drawing
mode.
<pre>
void GrMouseSetCursorMode(int mode,...);
</pre>
<p>&nbsp;&nbsp;The parameter <code>mode</code> can have the following values:
<pre>
#define GR_M_CUR_NORMAL   0    /* MOUSE CURSOR modes: just the cursor */
#define GR_M_CUR_RUBBER   1    /* rect. rubber band (XOR-d to the screen) */
#define GR_M_CUR_LINE     2    /* line attached to the cursor */
#define GR_M_CUR_BOX      3    /* rectangular box dragged by the cursor */
</pre>
<p>&nbsp;&nbsp;<code>GrMouseSetCursorMode</code> takes different parameters
depending on the cursor drawing mode selected. The accepted call formats are:
<pre>
GrMouseSetCursorMode(M_CUR_NORMAL); 
GrMouseSetCursorMode(M_CUR_RUBBER,xanchor,yanchor,GrColor); 
GrMouseSetCursorMode(M_CUR_LINE,xanchor,yanchor,GrColor); 
GrMouseSetCursorMode(M_CUR_BOX,dx1,dy1,dx2,dy2,GrColor); 
</pre>
<p>&nbsp;&nbsp;The anchor parameters for the rubberband and rubberline modes
specify a fixed screen location to which the other corner of the primitive
is bound. The <code>dx1</code> through <code>dy2</code> parameters define
the offsets of the corners of the dragged box from the hotpoint of the mouse
cursor. The color value passed is always XOR-ed to the screen, i.e. if an
application wants the rubberband to appear in a given color on a given
background then it has to pass the XOR of these two colors to
<code>GrMouseSetCursorMode</code>.

<hr>
<h2><a name="mdrv">The memory driver</a></h2>
<p>&nbsp;&nbsp;<b>MGRX</b> can be used to draw in memory using the memory driver,
so a graphic screen is not nedeed. After the drawing, the result can be stored in
a graphic file. This is the Hello MGRX example for the memory driver:

<pre>
#include &lt;string.h>
#include &lt;mgrx.h>

int main()
{
  char *message = "Hello, MGRX world";
  int x, y;
  GrTextOption grt;

  GrSetDriver( "memory gw 400 gh 400 nc 256" );
  GrSetMode( GR_default_graphics );

  grt.txo_font = &GrDefaultFont;
  grt.txo_fgcolor = GrWhite();
  grt.txo_bgcolor = GrBlack();
  grt.txo_direct = GR_TEXT_RIGHT;
  grt.txo_xalign = GR_ALIGN_CENTER;
  grt.txo_yalign = GR_ALIGN_CENTER;
  grt.txo_chrtype = GR_BYTE_TEXT;

  GrBox( 0,0,GrMaxX(),GrMaxY(),GrWhite() );
  GrBox( 4,4,GrMaxX()-4,GrMaxY()-4,GrWhite() );

  x = GrMaxX()/2;
  y = GrMaxY()/2;
  GrDrawString( message,strlen( message ),x,y,&grt );

  GrSaveContextToPpm( NULL,"memtest.ppm","GRX MemTest" );

  return 0;
}
</pre>

<hr>
<h2><a name="ref">References</a></h2>
<table>
<tr><td><a href="http://mgrx.fgrim.com">http://mgrx.fgrim.com</a></td>
<td>Official MGRX site</td></tr>
<tr><td><a href="http://grx.gnu.de">http://grx.gnu.de</a></td>
<td>GRX site (MGRX is derived from GRX)</td></tr>
<tr><td><a href="http://netpbm.sourceforge.net">http://netpbm.sourceforge.net</a></td>
<td>NetPbm distribution</td></tr>
<tr><td><a href="http://www.libpng.org/pub/png/libpng.html">http://www.libpng.org/pub/png/libpng.html</a></td>
<td>Libpng library</td></tr>
<tr><td><a href="http://www.ijg.org">http://www.ijg.org</a></td>
<td>Libjpeg library</td></tr>
</table>

</body>
</html>
