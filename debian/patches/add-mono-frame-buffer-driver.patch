Description: Add mono frame buffer driver
Author: David Lechner <david@lechnology.com>

---

--- a/include/grdriver.h
+++ b/include/grdriver.h
@@ -53,6 +53,8 @@
 _GrFrameDriverSVGA32L,                  /* Super VGA 16M color padded #1 */
 _GrFrameDriverSVGA32H,                  /* Super VGA 16M color padded #2 */
 					/* Linear Framebuffer Modes : */
+_GrFrameDriverMONO01_LFB,               /* mono, 0 = white, 1 = black */
+_GrFrameDriverMONO10_LFB,               /* mono, 1 = white, 0 = black */
 _GrFrameDriverSVGA8_LFB,                /* (Super) VGA 256 color */
 _GrFrameDriverSVGA16_LFB,               /* Super VGA 32768/65536 color */
 _GrFrameDriverSVGA24_LFB,               /* Super VGA 16M color */
--- a/include/grx20.h
+++ b/include/grx20.h
@@ -246,6 +246,8 @@
 	GR_frameSDL32L = GR_frameSVGA32L,
 	GR_frameSDL32H = GR_frameSVGA32H,
 	/* ==== linear frame buffer modes  ====== */
+	GR_frameMONO01_LFB,                 /* mono, 0 = white, 1 = black */
+	GR_frameMONO10_LFB,                 /* mono, 0 = black, 1 = white */
 	GR_frameSVGA8_LFB,                  /* (Super) VGA 256 color */
 	GR_frameSVGA16_LFB,                 /* Super VGA 32768/65536 color */
 	GR_frameSVGA24_LFB,                 /* Super VGA 16M color */
--- a/test/speedtst.c
+++ b/test/speedtst.c
@@ -190,6 +190,8 @@
     case GR_frameSVGA24: return sdl ? "SDL24" : x11 ? "XWIN24" : w32 ? "WIN32_24" : "SVGA24";
     case GR_frameSVGA32L: return sdl ? "SDL32L" : x11 ? "XWIN32L" : w32 ? "WIN32_32L" : "SVGA32L";
     case GR_frameSVGA32H: return sdl ? "SDL32H" : x11 ? "XWIN32H" : w32 ? "WIN32_32H" : "SVGA32H";
+    case GR_frameMONO01_LFB: return "LFB1-01";
+    case GR_frameMONO10_LFB: return "LFB1-10";
     case GR_frameSVGA8_LFB: return "LFB8";
     case GR_frameSVGA16_LFB: return "LFB16";
     case GR_frameSVGA24_LFB: return "LFB24";
--- a/src/vdrivers/vd_lnxfb.c
+++ b/src/vdrivers/vd_lnxfb.c
@@ -191,8 +191,15 @@
     if (grc == NULL)
         return;
     /* copy framebuffer to new context */
-    GrBitBlt(grc, 0, 0, GrScreenContext(), 0, 0,
-             GrScreenX()-1, GrScreenY()-1, GrWRITE);
+    if (GrScreenFrameMode() == GR_frameMONO01_LFB) {
+        /* Need to invert the colors on this one. */
+        GrClearContextC(grc, 1);
+        GrBitBlt(grc, 0, 0, GrScreenContext(), 0, 0,
+                 GrScreenX()-1, GrScreenY()-1, GrXOR);
+    } else {
+        GrBitBlt(grc, 0, 0, GrScreenContext(), 0, 0,
+                 GrScreenX()-1, GrScreenY()-1, GrWRITE);
+    }
     /*
      * swap out the framebuffer memory with the new context so that the
      * application can continue to run in the background without actually
@@ -217,14 +224,22 @@
     if (ttyfd < 0) return;
     /* resume control of the vt */
     ioctl(ttyfd, VT_RELDISP, VT_ACKACQ);
+    ioctl(ttyfd, KDSETMODE, KD_GRAPHICS);
     /* restore framebuffer address */
     GrScreenContext()->gc_baseaddr[0] = frame_addr[0];
     GrScreenContext()->gc_baseaddr[1] = frame_addr[1];
     GrScreenContext()->gc_baseaddr[2] = frame_addr[2];
     GrScreenContext()->gc_baseaddr[3] = frame_addr[3];
     /* copy the temporary context back to the framebuffer */
-    GrBitBlt(GrScreenContext(), 0, 0, grc, 0, 0,
-             GrScreenX()-1, GrScreenY()-1, GrWRITE);
+    if (GrScreenFrameMode() == GR_frameMONO01_LFB) {
+        /* need to invert the colors on this one */
+        GrClearScreen(1);
+        GrBitBlt(GrScreenContext(), 0, 0, grc, 0, 0,
+                 GrScreenX()-1, GrScreenY()-1, GrXOR);
+    } else {
+        GrBitBlt(GrScreenContext(), 0, 0, grc, 0, 0,
+                 GrScreenX()-1, GrScreenY()-1, GrWRITE);
+    }
     GrDestroyContext(grc);
     signal(SIGUSR1, _LnxfbRelsigHandle);
 }
@@ -330,6 +345,22 @@
     ep->setrwbanks = NULL;
     ep->loadcolor = NULL;
     switch (fbvar.bits_per_pixel) {
+    case 1:
+    if (fbfix.visual == FB_VISUAL_MONO01)
+        ep->mode = GR_frameMONO01_LFB;
+    else if (fbfix.visual == FB_VISUAL_MONO10)
+        ep->mode = GR_frameMONO10_LFB;
+    else
+        return FALSE;
+    mp->bpp = 1;
+    ep->flags |= GR_VMODEF_LINEAR;
+    ep->cprec[0] = fbvar.red.length;
+    ep->cprec[1] = fbvar.green.length;
+    ep->cprec[2] = fbvar.blue.length;
+    ep->cpos[0] = fbvar.red.offset;
+    ep->cpos[1] = fbvar.green.offset;
+    ep->cpos[2] = fbvar.blue.offset;
+    break;
     case 8:
 	if (fbfix.visual != FB_VISUAL_PSEUDOCOLOR)
 	    return FALSE;
--- a/src/fdrivers/ftable.c
+++ b/src/fdrivers/ftable.c
@@ -43,6 +43,8 @@
 #if defined(__DJGPP__) || defined(XF86DGA_FRAMEBUFFER) \
   || ( defined(LFB_BY_NEAR_POINTER) && !defined(__WIN32__) ) \
   || ( defined(__WATCOMC__) && defined ( __386__ ) )
+    &_GrFrameDriverMONO01_LFB,
+    &_GrFrameDriverMONO10_LFB,
     &_GrFrameDriverSVGA8_LFB,
     &_GrFrameDriverSVGA16_LFB,
     &_GrFrameDriverSVGA24_LFB,
--- a/src/fdrivers/ram1.c
+++ b/src/fdrivers/ram1.c
@@ -35,7 +35,16 @@
 	GR_int8u far *ptr;
 	GRX_ENTER();
 	ptr = (GR_int8u far *)&c->gf_baseaddr[0][FOFS(x,y,c->gf_lineoffset)];
-	GRX_RETURN((GrColor)( (*ptr >> (7 - (x & 7)) ) & 1));
+	GRX_RETURN((GrColor)( (*ptr >> (x & 7)) & 1));
+}
+
+static INLINE
+GrColor readpixel_inv(GrFrame *c,int x,int y)
+{
+    GR_int8u far *ptr;
+    GRX_ENTER();
+    ptr = (GR_int8u far *)&c->gf_baseaddr[0][FOFS(x,y,c->gf_lineoffset)];
+    GRX_RETURN((GrColor)(((*ptr >> (x & 7)) & 1) ? 0 : 1));
 }
 
 static INLINE
@@ -46,16 +55,22 @@
 
 	GRX_ENTER();
 	ptr = (GR_int8u far *)&CURC->gc_baseaddr[0][FOFS(x,y,CURC->gc_lineoffset)];
-	cval = (color & 1) << (7 - (x &= 7));
+	cval = (color & 1) << (x &= 7);
 	switch(C_OPER(color)) {
 	    case C_XOR: *ptr ^=  cval; break;
 	    case C_OR:  *ptr |=  cval; break;
 	    case C_AND: *ptr &= ~cval; break;
-	    default:    *ptr  = (*ptr & (~0x80 >> x)) | cval; break;
+	    default:    *ptr  = (*ptr & (~0x80 >> (7 -x))) | cval; break;
 	}
 	GRX_LEAVE();
 }
 
+static INLINE
+void drawpixel_inv(int x,int y, GrColor color)
+{
+    drawpixel(x, y, GrColorMode(color)|GrColorValue(~color));
+}
+
 #define maskoper(d,op,s,msk,SF,DF) do {                       \
     unsigned char _c_ = peek_b##DF(d);                        \
     poke_b##DF((d), (_c_ & ~(msk)) | ((_c_ op (s)) & (msk))); \
@@ -70,8 +85,8 @@
   oper = C_OPER(color);
   color &= 1;
   if (!( !color && (oper==C_OR||oper==C_XOR)) && !(color && oper==C_AND) ) {
-    GR_int8u lm = 0xff >> (x & 7);
-    GR_int8u rm = 0xff << ((-(w + x)) & 7);
+    GR_int8u lm = 0xff << (x & 7);
+    GR_int8u rm = 0xff >> ((-(w + x)) & 7);
     GR_int8u far *p = (GR_int8u far *)&CURC->gc_baseaddr[0][FOFS(x,y,CURC->gc_lineoffset)];
     GR_repl cv = 0;
     if (color) cv = ~cv;
@@ -109,6 +124,11 @@
   GRX_LEAVE();
 }
 
+static void drawhline_inv(int x,int y,int h, GrColor color)
+{
+    drawhline(x, y, h, GrColorMode(color)|GrColorValue(~color));
+}
+
 static void drawvline(int x,int y,int h,GrColor color)
 {
 	unsigned int lwdt, mask, oper;
@@ -117,7 +137,7 @@
 	oper = C_OPER(color);
 	color &= 1;
 	lwdt = CURC->gc_lineoffset;
-	mask = 0x80 >> (x & 7);
+	mask = 0x01 << (x & 7);
 	switch (oper) {
 	  case C_XOR:
 	      /* no need to xor anything with 0 */
@@ -150,6 +170,11 @@
 	GRX_LEAVE();
 }
 
+static void drawvline_inv(int x,int y,int h, GrColor color)
+{
+    drawvline(x, y, h, GrColorMode(color)|GrColorValue(~color));
+}
+
 static
 #include "fdrivers/generic/block.c"
 
@@ -170,7 +195,16 @@
 		   GrColor op)
 {
     GRX_ENTER();
-    _GR_rblit_14(dst,dx,dy,src,x,y,w,h,op,1,bitblt);
+    _GR_rblit_14(dst,dx,dy,src,x,y,w,h,op,1,bitblt,FALSE);
+    GRX_LEAVE();
+}
+
+static void bltr2r_inv(GrFrame *dst,int dx,int dy,
+                       GrFrame *src,int x,int y,int w,int h,
+                       GrColor op)
+{
+    GRX_ENTER();
+    _GR_rblit_14(dst,dx,dy,src,x,y,w,h,op,1,bitblt,TRUE);
     GRX_LEAVE();
 }
 
@@ -210,3 +244,50 @@
     _GrFrDrvGenericPutScanline
 };
 
+GrFrameDriver _GrFrameDriverMONO01_LFB = {
+    GR_frameMONO01_LFB,         /* frame mode */
+    GR_frameRAM1,               /* compatible RAM frame mode */
+    TRUE,                       /* onscreen */
+    4,                          /* scan line width alignment */
+    1,                          /* number of planes */
+    1,                          /* bits per pixel */
+    16*1024L*1024L,             /* max plane size the code can handle */
+    NULL,
+    readpixel_inv,
+    drawpixel_inv,
+    drawline,
+    drawhline_inv,
+    drawvline_inv,
+    drawblock,
+    drawbitmap,
+    drawpattern,
+    bltr2r,
+    bltr2r_inv,
+    bltr2r_inv,
+    getindexedscanline,
+    _GrFrDrvGenericPutScanline
+};
+
+GrFrameDriver _GrFrameDriverMONO10_LFB = {
+    GR_frameMONO10_LFB,         /* frame mode */
+    GR_frameRAM1,               /* compatible RAM frame mode */
+    TRUE,                       /* onscreen */
+    4,                          /* scan line width alignment */
+    1,                          /* number of planes */
+    1,                          /* bits per pixel */
+    16*1024L*1024L,             /* max plane size the code can handle */
+    NULL,
+    readpixel,
+    drawpixel,
+    drawline,
+    drawhline,
+    drawvline,
+    drawblock,
+    drawbitmap,
+    drawpattern,
+    bltr2r,
+    bltr2r,
+    bltr2r,
+    getindexedscanline,
+    _GrFrDrvGenericPutScanline
+};
\ No newline at end of file
--- a/src/fdrivers/rblit_14.c
+++ b/src/fdrivers/rblit_14.c
@@ -86,6 +86,13 @@
   GRX_LEAVE();
 }
 
+void invert_scanline(char far *sptr,int w)
+{
+  GRX_ENTER();
+  while (w--)
+    sptr[w] = ~sptr[w];
+  GRX_LEAVE();
+}
 
 extern void _GR_shift_scanline(GR_int8u far **dst,
 			       GR_int8u far **src,
@@ -96,7 +103,7 @@
 
 void _GR_rblit_14(GrFrame *dst,int dx,int dy,
 		  GrFrame *src,int x,int y,int w,int h,
-		  GrColor op, int planes, _GR_blitFunc bitblt)
+		  GrColor op, int planes, _GR_blitFunc bitblt, int invert)
 {
     int pl;
     GRX_ENTER();
@@ -104,8 +111,8 @@
       GR_int32u doffs, soffs;
       int oper    = C_OPER(op);
       int shift   = ((int)(x&7)) - ((int)(dx&7));
-      GR_int8u lm = 0xff >> (dx & 7);
-      GR_int8u rm = 0xff << ((-(w + dx)) & 7);
+      GR_int8u lm = 0xff << (dx & 7);
+      GR_int8u rm = 0xff >> ((-(w + dx)) & 7);
       int ws      = ((x+w+7) >> 3) - (x >> 3);
       int wd      = ((dx+w+7) >> 3) - (dx >> 3);
       int dskip   = dst->gf_lineoffset;
@@ -123,6 +130,8 @@
 	  if (shift) {
 	    while (hh-- > 0) {
 	      shift_scanline(LineBuff,sptr,ws,shift);
+	if (invert)
+	        invert_scanline(LineBuff,ws);
 	      put_scanline(dptr,LineBuff,wd,lm,rm,oper);
 	      dptr -= dskip;
 	      sptr -= sskip;
@@ -130,6 +139,8 @@
 	  } else {
 	    while (hh-- > 0) {
 	      get_scanline(LineBuff, sptr, ws);
+	      if (invert)
+	        invert_scanline(LineBuff,ws);
 	      put_scanline(dptr,LineBuff,wd,lm,rm,oper);
 	      dptr -= dskip;
 	      sptr -= sskip;
@@ -147,13 +158,18 @@
 	  if (shift) {
 	    while (hh-- > 0) {
 	      shift_scanline(LineBuff,sptr,ws,shift);
+	      if (invert)
+	        invert_scanline(LineBuff,ws);
 	      put_scanline(dptr,LineBuff,wd,lm,rm,oper);
 	      dptr += dskip;
 	      sptr += sskip;
 	    }
 	   } else {
 	     while (hh-- > 0) {
-	       put_scanline(dptr,sptr,wd,lm,rm,oper);
+	       get_scanline(LineBuff, sptr, ws);
+	       if (invert)
+	         invert_scanline(LineBuff,ws);
+	       put_scanline(dptr,LineBuff,wd,lm,rm,oper);
 	       dptr += dskip;
 	       sptr += sskip;
 	     }
--- a/src/fdrivers/ram4.c
+++ b/src/fdrivers/ram4.c
@@ -260,7 +260,7 @@
 		   GrColor op)
 {
     GRX_ENTER();
-    _GR_rblit_14(dst,dx,dy,src,x,y,w,h,op,4,bitblt);
+    _GR_rblit_14(dst,dx,dy,src,x,y,w,h,op,4,bitblt,FALSE);
     GRX_LEAVE();
 }
 
--- a/src/fdrivers/rblit_14.h
+++ b/src/fdrivers/rblit_14.h
@@ -18,4 +18,4 @@
 
 void _GR_rblit_14(GrFrame *dst,int dx,int dy,
 		  GrFrame *src,int x,int y,int w,int h,
-		  GrColor op, int planes, _GR_blitFunc bitblt);
+		  GrColor op, int planes, _GR_blitFunc bitblt, int invert);
